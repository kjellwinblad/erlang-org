<!DOCTYPE html>
<html lang="en">



<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

    <!-- Allow pinning of website on windows -->
    <meta name="application-name" content="Erlang.org">
    <meta name="msapplication-tooltip" content="The official home of the Erlang Programming Language">
    <meta name="msapplication-starturl" content="/" >

    <!-- Make the site look nicer on facebook -->
    <meta property="og:type" content="website">
    <meta property="og:site_name" content="Erlang.org">
    <meta property="og:title" content="Welcome to Erlang.org">
    <meta property="og:description" content="The official home of the Erlang Programming Language">
    <meta property="og:image" content="https://beta.erlang.org/assets/img/erlang-228x200.png">
    <meta property="og:image:secure_url" content="https://beta.erlang.org/assets/img/erlang-228x200.png">
    <meta property="og:url" content="https://beta.erlang.org/">

    <!-- Twitter metadata -->
    <meta name="twitter:card" content="summary" />
    <meta property="twitter:title" content="Index" />
    <meta name="twitter:site" content="@erlang_org" />

    <!-- Rich data for google search -->
    <script type="application/ld+json">
{"@type":"WebSite","url":"https://erlang.org/","headline":"Eep 0031 - Erlang/OTP","name":"Erlang.org","sameAs":["https://twitter.com/erlang_org","https://github.com/erlang/otp"],"@context":"https://schema.org"}</script>

    <title>Eep 0031 - Erlang/OTP</title>

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- tells iOS browsers to not show telephone numbers as links -->
    <meta name="format-detection" content="telephone=no">

    <meta name="application-name" content="Erlang.org">
    <meta name="description" content="The official home of the Erlang Programming Language">
    <meta name="keywords" content="Erlang programming language functional parallel distributed documentation download community">
    <!-- https://www.rssboard.org/rss-autodiscovery -->
    <link rel="alternate" type="application/atom+xml" title="News Atom Feed" href="https://beta.erlang.org/news.xml" />
    <link rel="alternate" type="application/atom+xml" title="Blog Atom Feed" href="https://beta.erlang.org/blog.xml" />
    
    <link rel="stylesheet" href="/assets/css/main.css">
</head>

<body>
    <header class="navbar navbar-expand-lg navbar-light bg-body">
        <nav class="container">
            <button class="navbar-toggler" type="button" data-toggle="collapse" data-bs-toggle="collapse"
                data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false"
                aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <a class="navbar-brand" href="/"><img
                    src="/assets/img/erlang.png" class="img-fluid" width="60" alt="Erlang.org main page"/></a>
            <div class="collapse navbar-collapse fw-bold" id="navbarSupportedContent">
                <ul class="navbar-nav text-uppercase me-auto mb-2 mb-lg-0">
                    <li class="nav-item"><a class="nav-link" href="/downloads">Download</a></li>
                    <li class="nav-item"><a class="nav-link" href="/docs">Documentation</a></li>
                    <li class="nav-item"><a class="nav-link" href="/community">Community</a></li>
                    <li class="nav-item"><a class="nav-link" href="/news">News</a></li>
                    <li class="nav-item"><a class="nav-link" href="/blog">Blog</a></li>
                    <li class="nav-item"><a class="nav-link" href="/eep">EEP</a></li>
                    <li class="nav-item"><a class="nav-link" href="/about">About</a></li>
                </ul>
                <form class="d-flex" role="search" method="get" action="https://duckduckgo.com/">
                    <input type="hidden" name="sites" value="erlang.org">
                    <input class="form-control me-2" id="searchfield" name="q" type="search" placeholder="Search erlang.org"
                        aria-label="Search">
                    <button class="btn btn-outline-primary" type="submit">Search</button>
                </form>
            </div>
        </nav>
    </header>
    <div class="container border-top pt-4">
    <div class="row-lg">
        <div class="col-lg-10 offset-lg-1">
            <div class="card">
                <div class="card-body">
                    <dl class="mb-0 dl-single">
                        <dt>Author:</dt>
                        <dd>
                            Patrik Nyblom &lt;pan(at)erlang(dot)org&gt;
                            
                            , 
                            
                            
                            Fredrik Svahn &lt;Fredrik(dot)Svahn(at)gmail&gt;
                            
                            
                        </dd>
                        
                        <dt>Status:</dt>
                        <dd>Final/R14A Proposal is implemented in OTP release R14A</dd>
                        <dt>Type:</dt>
                        <dd>Standards Track</dd>
                        
                        
                        <dt>Created:</dt>
                        <dd>28-Nov-2009</dd>
                        
                        <dt>Erlang-Version:</dt>
                        <dd>R13B03</dd>
                        
                        
                        
                        
                    </dl>
                </div>
            </div>
            <div class="border-top mt-4">
                
                <h2 id="eep-31-binary-manipulation-and-searching-module">
        
        
          EEP 31: Binary manipulation and searching module <a href="#eep-31-binary-manipulation-and-searching-module">#</a>
        
        
      </h2>
    
      <h1 id="abstract">
        
        
          Abstract <a href="#abstract">#</a>
        
        
      </h1>
    

<p>This EEP contains developed suggestions regarding the module <code>binary</code>
first suggested in <a href="eep-0009.md" title="EEP 9, the original work from which this EEP is derived">EEP 9</a>.</p>

<p><a href="eep-0009.md" title="EEP 9, the original work from which this EEP is derived">EEP 9</a> suggests several modules and is partially superseded by later
EEP’s (i.e. <a href="eep-0011.md" title="EEP 11, interesting extensions to EEP 9">EEP 11</a>), while still containing valuable suggestions not
yet implemented. The remaining modules from <a href="eep-0009.md" title="EEP 9, the original work from which this EEP is derived">EEP 9</a> will therefore
appear in separate EEP’s. This construction is made in agreement with
the original author of <a href="eep-0009.md" title="EEP 9, the original work from which this EEP is derived">EEP 9</a>.</p>

<p>The module <code>binary</code> is suggested to contain fast searching
algorithms together with some common operations on binaries already
present for lists (in the lists module).</p>
      <h1 id="motivation">
        
        
          Motivation <a href="#motivation">#</a>
        
        
      </h1>
    

<p>While efficient searching is already present in the <code>re</code> library,
dedicated search functions can further speed up searching in
binaries, given an efficient implementation (i.e. Boyer-More
and Aho-Corassick algorithm). Another important advantage of
separate searching algorithms are ease of use to the programmer,
as the suggested interfaces do not require knowledge about regular
expression syntax and special characters in the binaries need not
be escaped. It’s interesting to note how often regular expressions
are used for simple sub-string searching or replacement, which can
with this suggested module be done easily.</p>

<p>Decomposition of binaries are usually done by using bit-syntax.
However some common operations are useful to have as ordinary functions,
both for performance and to support a more traditional functional
programming style.</p>

<p>Some operations for converting lists to binaries and v.v. are today in
the erlang module. BIFs concerning binaries now present have varied
view of zero vs. one-based positioning in binaries. I.e.
<code>binary_to_list/3</code> uses one-based while <code>split_binary/2</code> uses
zero-based. As the convention is to use zero-based, new functions for
converting binaries to lists and v.v. are needed.</p>

<p>Binaries are in fact a shared data-type, with small binaries often
referencing parts of larger binaries in a way not controllable by
the programmer in a simple way. The bitstring data-type further
complicate things to the programmer in a way hard to easily
manage. I therefore also suggest some low level functions to
inspect binary representation and to clone binaries to ensure a
minimal representation.</p>

<p>As matching is not allowed in guard expressions, I furthermore suggest
that a function for extracting parts of binaries is added to the set
of guard BIFs. This would be consistent with the function element/2
being allowed in guards.</p>
      <h1 id="rationale">
        
        
          Rationale <a href="#rationale">#</a>
        
        
      </h1>
    

<p>For the lists data type there is a help library providing functions for
common operations such as searching and splitting lists.  This EEP suggests
that a similar set of library functions should be created for binaries.
Many of the proposed functions are based on answers to questions regarding
binaries on the erlang-questions mailing list, e.g. “how do I convert a
number to a binary?”. This EEP therefore suggests the addition of one
module in stdlib, namely a module <code>binary</code> which will implement the
requested functionality in an efficient way. Most of this module will
need to be implemented in native code (residing in the virtual
machine) why the proposed implementation will be delivered as “beta”
functionality in a forthcoming Erlang release.</p>

<p>The functionality suggested is the following:</p>

<ul>
  <li>
    <p>Functionality for searching, splitting and replacing in
binaries. The functionality in some ways will overlap that of the
regular expression library already present in Erlang, but will be
even more efficient and will have a simpler interface.</p>
  </li>
  <li>
    <p>Common operations on binaries that have their counterparts for lists
already in the stdlib module <code>lists</code>. While not all interfaces in
the <code>lists</code> module are applicable to binaries, many are. This module
also provides a good place for future operations on binaries,
operations that are not applicable to lists or that we still don’t
know the need for.</p>
  </li>
  <li>
    <p>Functions for converting lists to binaries and v.v. These functions
should have a consistent view of zero-based indexing in binaries.</p>
  </li>
  <li>
    <p>Operations on binaries concerning their internal
representation. This functionality is sometimes necessary to avoid
extensive use of memory due to the shared nature of the binaries. As
operations on binaries do not involve copying when binaries are
taken apart, programs can unknowingly (or at least unintentionally)
keep references to large binaries by holding seemingly small amounts
of data in the process. The O(1) nature of many operations on
binaries makes the data sharing necessary, but the effects can
sometimes be surprising. On the other hand, O(n) complexity and
instant memory explosions when splitting a binary would be even more
surprising, why the current behavior need to be retained. It is suggested
that functions for both inspecting the nature of sharing of a binary
and to clone a copy of a binary to avoid sharing effects is present
in this suggested module.</p>
  </li>
</ul>

<p>All functionality is to be applied to byte oriented binaries, never
bitstrings that do not have a bitlength that is a multiple of
eight. All binaries supplied to and returned by these functions should
pass the <code>is_binary/1</code> test, otherwise an error will be raised.</p>
      <h2 id="suggested-module-reference">
        
        
          Suggested module reference <a href="#suggested-module-reference">#</a>
        
        
      </h2>
    

<p>I suggest the following functionality (presented as an excerpt of an Erlang
manual pages). A discussion about the interface can be found below.</p>
      <h3 id="data-types">
        
        
          DATA TYPES <a href="#data-types">#</a>
        
        
      </h3>
    

<pre><code class="language-erlang">cp()
</code></pre>

<p>Opaque data-type representing a compiled search-pattern.
guaranteed to be a tuple() to allow programs to distinguish it from
non precompiled search patterns.</p>

<pre><code class="language-erlang">part() = {Pos,Length}

Start = int()
Length = int()
</code></pre>

<p>A representation of a part (or range) in a binary. <code>Start</code> is a
zero-based offset into a binary() and Length is the length of that
part. As input to functions in this module, a reverse part
specification is allowed, constructed with a negative <code>Length</code>, so
that the part of the binary begins at <code>Start</code> + <code>Length</code> and is
-<code>Length</code> long. This is useful for referencing the last N bytes
of a binary as <code>{size(Binary), -N}</code>. The functions in this module
always return part()’s with positive <code>Length</code>.</p>
      <h3 id="exports">
        
        
          EXPORTS <a href="#exports">#</a>
        
        
      </h3>
    
      <h4 id="compile_patternpattern---cp">
        
        
          <code>compile_pattern(Pattern) -&gt; cp()</code> <a href="#compile_patternpattern---cp">#</a>
        
        
      </h4>
    

<p>Types:</p>

<pre><code class="language-erlang">Pattern = binary() | [ binary() ]
</code></pre>

<p>Builds an internal structure representing a compilation of a
search-pattern, later to be used in the find, split or replace
functions. The cp() returned is guaranteed to be a tuple() to allow
programs to distinguish it from non precompiled search patterns</p>

<p>When a list of binaries is given, it denotes a <em>set</em> of alternative
binaries to search for. I.e if <code>[&lt;&lt;"functional"&gt;&gt;, &lt;&lt;"programming"&gt;&gt;]</code> 
is given as <code>Pattern</code>, this means ‘‘either <code>&lt;&lt;"functional"&gt;&gt;</code> <em>or</em>
<code>&lt;&lt;"programming"&gt;&gt;</code>’’. The pattern is a <em>set</em> of alternatives; when
only a single binary is given, the set has only one element.</p>

<p>If pattern is not a binary or a flat proper list of binaries, a <code>badarg</code>
exception will be raised.</p>
      <h4 id="matchsubject-pattern---found--no">
        
        
          <code>match(Subject, Pattern) -&gt; Found | no</code> <a href="#matchsubject-pattern---found--no">#</a>
        
        
      </h4>
    

<p>Types:</p>

<pre><code class="language-erlang">Subject = binary()
Pattern = binary() | [ binary() ] | cp()
Found = part()
</code></pre>

<p>The same as <code>match(Subject, Pattern, [])</code>.</p>
      <h4 id="matchsubjectpatternoptions---found--no">
        
        
          <code>match(Subject,Pattern,Options) -&gt; Found | no</code> <a href="#matchsubjectpatternoptions---found--no">#</a>
        
        
      </h4>
    

<p>Types:</p>

<pre><code class="language-erlang">Subject = binary()
Pattern = binary() | [ binary() ] | cp()
Found = part()
Options = [ Option ]
Option = {scope, part()}
</code></pre>

<p>Searches for the first occurrence of <code>Pattern</code> in <code>Subject</code> and returns
the position and length.</p>

<p>The function will return
<code>{Pos,Length}</code> for the binary in <code>Pattern</code> starting at
the lowest position in <code>Subject</code>.</p>

<p>Example::</p>

<pre><code class="language-erlang">1&gt; binary:find(&lt;&lt;"abcde"&gt;&gt;, [&lt;&lt;"bcde"&gt;&gt;,&lt;&lt;"cd"&gt;&gt;],[]).
{1,4}
</code></pre>

<p>Even though <code>&lt;&lt;"cd"&gt;&gt;</code> ends before <code>&lt;&lt;"bcde"&gt;&gt;</code>, <code>&lt;&lt;"bcde"&gt;&gt;</code>
begins first and is therefore the first match. If two overlapping
matches begins at the same position, the longest is returned.</p>

<p>Summary of the options:</p>

<ul>
  <li>
    <p><code>{scope, {Start, Length}}</code>  <br />
Only the given part is searched. Return values still have offsets
from the beginning of <code>Subject</code>. A negative <code>Length</code> is
allowed as described in the <strong>TYPES</strong> section of this manual.</p>

    <p>The found part() is returned, if none of the strings in <code>Pattern</code> is
found, the atom <code>no</code> is returned.</p>

    <p>For a description of <code>Pattern</code>, see <code>compile_pattern/1</code>.</p>

    <p>If <code>{scope, {Start,Length}}</code> is given in the options such that
<code>Start</code> is larger than the size of <code>Subject</code>, <code>Start</code> +
<code>Length</code> is less than zero or <code>Start</code> + <code>Length</code> is larger than
the size of <code>Subject</code>, a <code>badarg</code> exception is raised.</p>
  </li>
</ul>
      <h4 id="matchessubject-pattern---found">
        
        
          <code>matches(Subject, Pattern) -&gt; Found</code> <a href="#matchessubject-pattern---found">#</a>
        
        
      </h4>
    

<p>Types:</p>

<pre><code class="language-erlang">Subject = binary()
Pattern = binary() | [ binary() ] | cp()
Found = [ part() ] | []
</code></pre>

<p>The same as <code>matches(Subject, Pattern, [])</code>.</p>
      <h4 id="matchessubjectpatternoptions---found">
        
        
          <code>matches(Subject,Pattern,Options) -&gt; Found</code> <a href="#matchessubjectpatternoptions---found">#</a>
        
        
      </h4>
    

<p>Types:</p>

<pre><code class="language-erlang">Subject = binary()
Pattern = binary() | [ binary() ] | cp()
Found = [ part() ] | []
Options = [ Option ]
Option = {scope, part()}
</code></pre>

<p>Works like match, but the <code>Subject</code> is search until exhausted and
a list of all non-overlapping parts present in Pattern are returned (in order).</p>

<p>The first and <em>longest</em> match is preferred
to a shorter, which is illustrated by the following example::</p>

<pre><code class="language-erlang">1&gt; binary:matches(&lt;&lt;"abcde"&gt;&gt;, [&lt;&lt;"bcde"&gt;&gt;,&lt;&lt;"bc"&gt;&gt;&gt;,&lt;&lt;"de"&gt;&gt;],[]).
[{1,4}]
</code></pre>

<p>The result shows that <code>&lt;&lt;"bcde"&gt;&gt;&gt;</code> is selected instead of the
shorter match <code>&lt;&lt;"bc"&gt;&gt;</code> (which would have given raise to one more
match,<code>&lt;&lt;"de"&gt;&gt;</code>). This corresponds to the behavior of
posix regular expressions (and programs like <code>awk</code>), but is not
consistent with alternative matches in <code>re</code> (and Perl), where
instead lexical ordering in the search pattern selects which string
matches.</p>

<p>If none of the strings in pattern is found, an empty list is returned.</p>

<p>For a description of <code>Pattern</code>, see <code>compile_pattern/1</code> and for a
desctioption of available options, see <code>match/3</code>.</p>

<p>If <code>{scope, {Start,Length}}</code> is given in the options such that
<code>Start</code> is larger than the size of <code>Subject</code>, <code>Start</code> +
<code>Length</code> is less than zero or <code>Start</code> + <code>Length</code> is larger than
the size of <code>Subject</code>, a <code>badarg</code> exception is raised.</p>
      <h4 id="splitsubjectpattern---parts">
        
        
          <code>split(Subject,Pattern) -&gt; Parts</code> <a href="#splitsubjectpattern---parts">#</a>
        
        
      </h4>
    

<p>Types:</p>

<pre><code class="language-erlang">Subject = binary()
Pattern = binary() | [ binary() ] | cp()
Parts = [ binary() ]
</code></pre>

<p>The same as <code>split(Subject, Pattern, [])</code>.</p>
      <h4 id="splitsubjectpatternoptions---parts">
        
        
          <code>split(Subject,Pattern,Options) -&gt; Parts</code> <a href="#splitsubjectpatternoptions---parts">#</a>
        
        
      </h4>
    

<p>Types:</p>

<pre><code class="language-erlang">Subject = binary()
Pattern = binary() | [ binary() ] | cp()
Parts = [ binary() ]
Options = [ Option ]
Option = {scope, part()} | trim | global
</code></pre>

<p>Splits Binary into a list of binaries based on <code>Pattern</code>. If the
option <code>global</code> is not given, only the first occurrence of
<code>Pattern</code> in <code>Subject</code> will give rise to a split.</p>

<p>The parts of <code>Pattern</code> actually found in <code>Subject</code> are not included
in the result.</p>

<p>Example::</p>

<pre><code class="language-erlang">1&gt; binary:split(&lt;&lt;1,255,4,0,0,0,2,3&gt;&gt;, [&lt;&lt;0,0,0&gt;&gt;,&lt;&lt;2&gt;&gt;],[]).
[&lt;&lt;1,255,4&gt;&gt;, &lt;&lt;2,3&gt;&gt;] 
2&gt; binary:split(&lt;&lt;0,1,0,0,4,255,255,9&gt;&gt;, [&lt;&lt;0,0&gt;&gt;, &lt;&lt;255,255&gt;&gt;],[global]).
[&lt;&lt;0,1&gt;&gt;,&lt;&lt;4&gt;&gt;,&lt;&lt;9&gt;&gt;] 
</code></pre>

<p>Summary of options:</p>

<ul>
  <li>
    <p><code>{scope, part()}</code>  <br />
Works as in <code>binary:match/3</code> and <code>binary:matches/3</code>. Note
that this only defines the scope of the search for matching
strings, it does not cut the binary before splitting. The
bytes before and after the scope will be kept in the result.
See example below.</p>
  </li>
  <li>
    <p><code>trim</code>  <br />
Removes trailing empty parts of the result (as does <code>trim</code>
in <code>re:split/3</code>)</p>
  </li>
  <li>
    <p><code>global</code>  <br />
Repeats the split until the <code>Subject</code> is
exhausted. Conceptually the <code>global</code> option makes <code>split</code>
work on the positions returned by <code>binary:matches/3</code>, while
it normally works on the position returned by
<code>binary:match/3</code>.</p>
  </li>
</ul>

<p>Example of the difference between a <code>scope</code> and taking the binary apart 
before splitting::</p>

<pre><code class="language-erlang">1&gt; binary:split(&lt;&lt;"banana"&gt;&gt;,[&lt;&lt;"a"&gt;&gt;],[{scope,{2,3}}]).
[&lt;&lt;"ban"&gt;&gt;,&lt;&lt;"na"&gt;&gt;]
2&gt; binary:split(binary:part(&lt;&lt;"banana"&gt;&gt;,{2,3}),[&lt;&lt;"a"&gt;&gt;],[]).
[&lt;&lt;"n"&gt;&gt;,&lt;&lt;"n"&gt;&gt;]
</code></pre>

<p>The return type is always a list of binaries which are all referencing
<code>Subject</code>. This means that the data in <code>Subject</code> is not actually
copied to new binaries and that <code>Subject</code> cannot be garbage
collected until the results of the split are no longer referenced.</p>

<p>For a description of <code>Pattern</code>, see <code>compile_pattern/1</code>.</p>
      <h4 id="replacesubjectpatternreplacement---result">
        
        
          <code>replace(Subject,Pattern,Replacement) -&gt; Result</code> <a href="#replacesubjectpatternreplacement---result">#</a>
        
        
      </h4>
    

<p>Types:</p>

<pre><code class="language-erlang">Subject = binary()
Pattern = binary() | [ binary() ] | cp()
Replacement = binary()
Result = binary()
</code></pre>

<p>The same as <code>replace(Subject,Pattern,Replacement,[])</code>.</p>
      <h4 id="replacesubjectpatternreplacementoptions---result">
        
        
          <code>replace(Subject,Pattern,Replacement,Options) -&gt; Result</code> <a href="#replacesubjectpatternreplacementoptions---result">#</a>
        
        
      </h4>
    

<p>Types:</p>

<pre><code class="language-erlang">Subject = binary()
Pattern = binary() | [ binary() ] | cp()
Replacement = binary()
Result = binary()
Options = [ Option ]
Option = global | {scope, part()} | {insert_replaced, InsPos}
InsPos = OnePos | [ OnePos ]
OnePos = int() =&lt; byte_size(Replacement)
</code></pre>

<p>Constructs a new binary by replacing the parts in <code>Subject</code> matching
<code>Pattern</code> with the content of <code>Replacement</code>.</p>

<p>If the matching sub-part of <code>Subject</code> giving raise to the
replacement is to be inserted in the result, the option
<code>{insert_replaced, InsPos}</code> will insert the matching part into
<code>Replacement</code> at the given position (or positions) before actually
inserting <code>Replacement</code> into the Subject. Example::</p>

<pre><code class="language-erlang">1&gt; binary:replace(&lt;&lt;"abcde"&gt;&gt;,&lt;&lt;"b"&gt;&gt;,&lt;&lt;"[]"&gt;&gt;,[{insert_replaced,1}]).
&lt;&lt;"a[b]cde"&gt;&gt;
2&gt; binary:replace(&lt;&lt;"abcde"&gt;&gt;,[&lt;&lt;"b"&gt;&gt;,&lt;&lt;"d"&gt;&gt;],&lt;&lt;"[]"&gt;&gt;,
                 [global,{insert_replaced,1}]).
&lt;&lt;"a[b]c[d]e"&gt;&gt;
3&gt; binary:replace(&lt;&lt;"abcde"&gt;&gt;,[&lt;&lt;"b"&gt;&gt;,&lt;&lt;"d"&gt;&gt;],&lt;&lt;"[]"&gt;&gt;,
                 [global,{insert_replaced,[1,1]}]).
&lt;&lt;"a[bb]c[dd]e"&gt;&gt;
4&gt; binary:replace(&lt;&lt;"abcde"&gt;&gt;,[&lt;&lt;"b"&gt;&gt;,&lt;&lt;"d"&gt;&gt;],&lt;&lt;"[-]"&gt;&gt;,
                 [global,{insert_replaced,[1,2]}]).
&lt;&lt;"a[b-b]c[d-d]e"&gt;&gt;
</code></pre>

<p>If any position given in <code>InsPos</code> is greater than the size of
the replacement binary, a <code>badarg</code> exception is raised.</p>

<p>The options <code>global</code> and <code>{scope, part()}</code> works as for
<code>binary:split/3</code>. The return type is always a binary.</p>

<p>For a description of <code>Pattern</code>, see <code>compile_pattern/1</code>.</p>
      <h4 id="longest_common_prefixbinaries---int">
        
        
          <code>longest_common_prefix(Binaries) -&gt; int()</code> <a href="#longest_common_prefixbinaries---int">#</a>
        
        
      </h4>
    

<p>Types:</p>

<pre><code class="language-erlang">Binaries = [ binary() ]
</code></pre>

<p>Returns the length of the longest common prefix of the binaries in the
list <code>Binaries</code>. Example::</p>

<pre><code class="language-erlang">1&gt; binary:longest_common_prefix([&lt;&lt;"erlang"&gt;&gt;,&lt;&lt;"ergonomy"&gt;&gt;]).
2
2&gt; binary:longest_common_prefix([&lt;&lt;"erlang"&gt;&gt;,&lt;&lt;"perl"&gt;&gt;]).
0
</code></pre>

<p>If <code>Binaries</code> is not a flat list of binaries, a <code>badarg</code> exception
is raised.</p>
      <h4 id="longest_common_suffixbinaries---int">
        
        
          <code>longest_common_suffix(Binaries) -&gt; int()</code> <a href="#longest_common_suffixbinaries---int">#</a>
        
        
      </h4>
    

<p>Types:</p>

<pre><code class="language-erlang">Binaries = [ binary() ]
</code></pre>

<p>Returns the length of the longest common suffix of the binaries in the
list <code>Binaries</code>. Example::</p>

<pre><code class="language-erlang">1&gt; binary:longest_common_suffix([&lt;&lt;"erlang"&gt;&gt;,&lt;&lt;"fang"&gt;&gt;]).
3
2&gt; binary:longest_common_suffix([&lt;&lt;"erlang"&gt;&gt;,&lt;&lt;"perl"&gt;&gt;]).
0
</code></pre>

<p>If <code>Binaries</code> is not a flat list of binaries, a <code>badarg</code> exception
is raised.</p>
      <h4 id="firstsubject---int">
        
        
          <code>first(Subject) -&gt; int()</code> <a href="#firstsubject---int">#</a>
        
        
      </h4>
    

<p>Types:</p>

<pre><code class="language-erlang">Subject = binary()
</code></pre>

<p>Returns the first byte of the binary as an integer. If the binary
length is zero, a <code>badarg</code> exception is raised.</p>
      <h4 id="lastsubject---int">
        
        
          <code>last(Subject) -&gt; int()</code> <a href="#lastsubject---int">#</a>
        
        
      </h4>
    

<p>Types:</p>

<pre><code class="language-erlang">Subject = binary()
</code></pre>

<p>Returns the last byte of the binary as an integer. If the binary
length is zero, a <code>badarg</code> exception is raised.</p>
      <h4 id="atsubject-pos---int">
        
        
          <code>at(Subject, Pos) -&gt; int()</code> <a href="#atsubject-pos---int">#</a>
        
        
      </h4>
    

<p>Types:</p>

<pre><code class="language-erlang">Subject = binary()
Pos = int() &gt;= 0
</code></pre>

<p>Returns the byte at position <code>Pos</code> (zero-based) in the binary
<code>Subject</code> as an integer. If <code>Pos</code> &gt;= <code>byte_size(Subject)</code>, a
<code>badarg</code> exception is raised.</p>
      <h4 id="partsubject-poslen---binary">
        
        
          <code>part(Subject, PosLen) -&gt; binary()</code> <a href="#partsubject-poslen---binary">#</a>
        
        
      </h4>
    

<p>Types:</p>

<pre><code class="language-erlang">Subject = binary()
PosLen = part()
</code></pre>

<p>Extracts the part of the binary described by <code>PosLen</code>.</p>

<p>Negative length can be used to extract bytes at the end of a binary::</p>
<pre><code class="language-erlang">1&gt; Bin = &lt;&lt;1,2,3,4,5,6,7,8,9,10&gt;&gt;.
2&gt; binary:part(Bin,{byte_size(Bin), -5)).
&lt;&lt;6,7,8,9,10&gt;&gt;
</code></pre>

<p>If <code>PosLen</code> in any way references outside the binary, a <code>badarg</code>
exception is raised.</p>
      <h4 id="partsubject-pos-len---binary">
        
        
          <code>part(Subject, Pos, Len) -&gt; binary()</code> <a href="#partsubject-pos-len---binary">#</a>
        
        
      </h4>
    

<p>Types:</p>

<pre><code class="language-erlang">Subject = binary()
Pos = int()
Len = int()
</code></pre>

<p>The same as <code>part(Subject, {Pos, Len})</code>.</p>
      <h4 id="bin_to_listsubject---list">
        
        
          <code>bin_to_list(Subject) -&gt; list()</code> <a href="#bin_to_listsubject---list">#</a>
        
        
      </h4>
    

<p>Types:</p>

<pre><code class="language-erlang">Subject = binary()
</code></pre>

<p>The same as <code>bin_to_list(Subject,{0,byte_size(Subject)})</code>.</p>
      <h4 id="bin_to_listsubject-poslen---list">
        
        
          <code>bin_to_list(Subject, PosLen) -&gt; list()</code> <a href="#bin_to_listsubject-poslen---list">#</a>
        
        
      </h4>
    

<pre><code class="language-erlang">Subject = binary()
PosLen = part()
</code></pre>

<p>Converts <code>Subject</code> to a list of int(), each int representing the
value of one byte. The <code>part()</code> denotes which part of the
<code>binary()</code> to convert. Example::</p>

<pre><code class="language-erlang">1&gt; binary:bin_to_list(&lt;&lt;"erlang"&gt;&gt;,{1,3}).
"rla"
%% or [114,108,97] in list notation.
</code></pre>

<p>If <code>PosLen</code> in any way references outside the binary, a <code>badarg</code>
exception is raised.</p>
      <h3 id="bin_to_listsubject-pos-len---list">
        
        
          <code>bin_to_list(Subject, Pos, Len) -&gt; list()</code> <a href="#bin_to_listsubject-pos-len---list">#</a>
        
        
      </h3>
    

<p>Types:</p>

<pre><code class="language-erlang">Subject = binary()
Pos = int()
Len = int()
</code></pre>

<p>The same as <code>bin_to_list(Subject,{Pos,Len})</code>.</p>
      <h4 id="list_to_binbytelist---binary">
        
        
          <code>list_to_bin(ByteList) -&gt; binary()</code> <a href="#list_to_binbytelist---binary">#</a>
        
        
      </h4>
    

<p>Types:</p>

<pre><code class="language-erlang">ByteList = iodata() (see module erlang)
</code></pre>

<p>Works exactly like <code>erlang:list_to_binary/1</code>, added for completeness.</p>
      <h4 id="copysubject---binary">
        
        
          <code>copy(Subject) -&gt; binary()</code> <a href="#copysubject---binary">#</a>
        
        
      </h4>
    

<p>Types:</p>

<pre><code class="language-erlang">Subject = binary()
</code></pre>

<p>The same as <code>copy(Subject, 1)</code>.</p>
      <h3 id="copysubjectn---binary">
        
        
          <code>copy(Subject,N) -&gt; binary()</code> <a href="#copysubjectn---binary">#</a>
        
        
      </h3>
    

<p>Types:</p>

<pre><code class="language-erlang">Subject = binary()
N = int() &gt;= 0
</code></pre>

<p>Creates a binary with the content of <code>Subject</code> duplicated <code>N</code>
times.</p>

<p>This function will always create a new binary, even if <code>N</code> = 1. By
using <code>copy/1</code> on a binary referencing a larger binary, one might
free up the larger binary for garbage collection.</p>

<blockquote class='blockquote'>
  <p>NOTE! By deliberately copying a single binary to avoid referencing a
larger binary, one might, instead of freeing up the larger binary for
later garbage collection, create much more binary data than
needed. Sharing binary data is usually good. Only in special cases,
when small parts reference large binaries and the large binaries are
no longer used <em>in any process</em>, deliberate copying might be a good idea.</p>
</blockquote>

<p>If <code>N</code> &lt; 0, a <code>badarg</code> exception is raised.</p>
      <h4 id="referenced_byte_sizebinary---int">
        
        
          <code>referenced_byte_size(binary()) -&gt; int()</code> <a href="#referenced_byte_sizebinary---int">#</a>
        
        
      </h4>
    

<p>If a binary references a larger binary (often described as being a
sub-binary), it can be useful to get the size of the actual referenced
binary. This function can be used in a program to trigger the
use of <code>copy/1</code>. By copying a binary, one might dereference the
original, possibly large, binary which a smaller binary is a reference
to.</p>

<p>Example::</p>

<pre><code class="language-erlang">store(Binary, GBSet) -&gt;
  NewBin = 
      case binary:referenced_byte_size(Binary) of
          Large when Large &gt; 2 * byte_size(Binary) -&gt;
      	     binary:copy(Binary);
          _ -&gt;
	     Binary
      end,
  gb_sets:insert(NewBin,GBSet).
</code></pre>

<p>In this example, we chose to copy the binary content before inserting
it in the <code>gb_set()</code> if it references a binary more than twice the size
of the data we’re going to keep. Of course different rules for when
copying will apply to different programs.</p>

<p>Binary sharing will occur whenever binaries are taken apart, this is
the fundamental reason why binaries are fast, decomposition can always
be done with O(1) complexity. In rare circumstances this data sharing
is however undesirable, why this function together with <code>copy/1</code>
might be useful when optimizing for memory use.</p>

<p>Example of binary sharing::</p>

<pre><code class="language-erlang">1&gt; A = binary:copy(&lt;&lt;1&gt;&gt;,100).
&lt;&lt;1,1,1,1,1 ...
2&gt; byte_size(A).
100
3&gt; binary:referenced_byte_size(A)
100
4&gt; &lt;&lt;_:10/binary,B:10/binary,_/binary&gt;&gt; = A.
&lt;&lt;1,1,1,1,1 ...
5&gt; byte_size(B).
10
6&gt; binary:referenced_byte_size(B)
100
</code></pre>

<blockquote class='blockquote'>
  <p>NOTE! Binary data is shared among processes. If another process still
references the larger binary, copying the part this process uses only
consumes more memory and will not free up the larger binary for garbage
collection. Use this kind of intrusive functions with extreme care,
and only if a <em>real</em> problem is detected.</p>
</blockquote>
      <h4 id="encode_unsignedunsigned---binary">
        
        
          <code>encode_unsigned(Unsigned) -&gt; binary()</code> <a href="#encode_unsignedunsigned---binary">#</a>
        
        
      </h4>
    

<p>Types:</p>

<pre><code class="language-erlang">Unsigned = int() &gt;= 0
</code></pre>

<p>The same as <code>encode_unsigned(Unsigned,big)</code>.</p>
      <h4 id="encode_unsignedunsignedendianess---binary">
        
        
          <code>encode_unsigned(Unsigned,Endianess) -&gt; binary()</code> <a href="#encode_unsignedunsignedendianess---binary">#</a>
        
        
      </h4>
    

<p>Types:</p>

<pre><code class="language-erlang">Unsigned = int() &gt;= 0
Endianess = big | little
</code></pre>

<p>Converts a positive integer to the smallest possible representation
in in a binary digit representation, either big or little endian.</p>

<p>Example:</p>

<pre><code class="language-erlang">1&gt; binary:encode_unsigned(11111111,big). 
&lt;&lt;169,138,199&gt;&gt;
</code></pre>
      <h4 id="decode_unsignedsubject---unsigned">
        
        
          <code>decode_unsigned(Subject) -&gt; Unsigned</code> <a href="#decode_unsignedsubject---unsigned">#</a>
        
        
      </h4>
    

<p>Types:</p>

<pre><code class="language-erlang">Subject = binary()
Unsigned = int() &gt;= 0
</code></pre>

<p>The same as <code>encode_unsigned(Subject,big)</code>.</p>
      <h4 id="decode_unsignedsubject-endianess---unsigned">
        
        
          <code>decode_unsigned(Subject, Endianess) -&gt; Unsigned</code> <a href="#decode_unsignedsubject-endianess---unsigned">#</a>
        
        
      </h4>
    

<p>Types:</p>

<pre><code class="language-erlang">Subject = binary()
Endianess = big | little
Unsigned = int() &gt;= 0
</code></pre>

<p>Converts the binary digit representation, in big or little endian, of
a positive integer in <code>Subject</code> to an Erlang int().</p>

<p>Example::</p>

<pre><code class="language-erlang">1&gt; binary:decode_unsigned(&lt;&lt;169,138,199&gt;&gt;,big). 
11111111
</code></pre>
      <h2 id="guard-bif">
        
        
          Guard BIF <a href="#guard-bif">#</a>
        
        
      </h2>
    

<p>I suggest adding the functions <code>binary:part/2</code> and <code>binary:part/3</code>
to the set of BIFs allowed in guard tests. As guard BIFs are traditionally
put in the erlang module, the following names for the guard BIFs are
suggested::</p>

<pre><code class="language-erlang">erlang:binary_part/2
erlang:binary_part/3
</code></pre>

<p>They should both work exactly as their counterparts in the binary module.</p>
      <h2 id="interface-design-discussion">
        
        
          Interface design discussion <a href="#interface-design-discussion">#</a>
        
        
      </h2>
    

<p>As with all modules, there are a lot of arguments about the actual
interface, sometimes more than about the functionality. In this case a
number of parameters has to be considered.</p>

<ul>
  <li>
    <p>Effectiveness - The interface should be constructed so that fast
implementation is possible and so that code using the interface can
be written in an effective way. To not create unnecessary garbage is
one parameter, to allow for general code is another.</p>
  </li>
  <li>
    <p>Parameter ordering - I’ve chosen to make the binary subject the
first parameter in all applicable calls. Putting the subject first
corresponds to the <code>re</code> interface. The <code>lists</code> module, however,
usually has the subject as last parameter. We could go for that
instead, but unfortunately the <code>lists:sublist/{2,3}</code> interface,
which corresponds to the <code>part</code> function, has the subject
first, why following the conventions of <code>lists</code> would not only
break conformance with <code>re</code>, it would also give us a generally
non-stringent interface. The effect of not conforming to the
<code>lists</code> interface is that using function names from that module
would lead to confusion and therefore is avoided.</p>
  </li>
  <li>
    <p>Function naming - We have two related modules to take into account
when naming functions here. The module <code>re</code> is related to the
searching function (<code>match</code>, <code>replace</code> etc), while the <code>lists</code>
module is related to the decomposition functions (<code>first</code>,
<code>last</code> etc).</p>

    <p>I’ve basically retained the names from <code>re</code> when I find the
functionality, both in concept and interface to be similar
enough. The nature of regular expressions as small executable
programs, which is to much to say for a collection of binaries as
the patterns are in this module, prohibits the use of the function
name <code>run</code> for actually doing the searching. We use <code>match</code> and 
<code>matches</code> instead of <code>run</code>.</p>

    <p>As this module is more general than <code>re</code>, a function name like
<code>compile</code> is not really good. <code>re:compile</code> means “compile a
regular expression”, but what would <code>binary:compile</code> mean?
Therefore the pre-processing function is instead called
<code>compile_pattern</code>.</p>

    <p>When it comes to the <code>lists</code> module, the parameter ordering has
prevented me from reusing any function names but <code>last</code>, which
only takes one parameter in <code>lists</code> and there is no real
alternative there.</p>
  </li>
  <li>
    <p>Options or multiple functions - I believe a good rule of thumb is to
not have options that change the return type of the function, which
would have been the case if we i.e. had a <code>global</code> option to
<code>match/3</code> instead of a separate <code>matches/3</code> function.</p>

    <p>The fact that there are a manageable set of possible return types
for the searching and decomposition functions allows us to follow
that rule of thumb.</p>

    <p>(Unfortunately that rule could not be easily followed in <code>re</code>, as the
rich assortment of options would have given rise to a non-manageable
amount of function names).</p>
  </li>
</ul>
      <h1 id="performance">
        
        
          Performance <a href="#performance">#</a>
        
        
      </h1>
    

<p>Although the decomposition functions are not really faster than using
bit-syntax for decomposition, they create slightly less garbage than
the bit syntax. As they are not slower than bit-syntax, they also have
a purpose in allowing for a different programming style.</p>

<p>The match/replace/split functionality should be compared to similar
functionality in the <code>re</code> module. Implementation methods has to be
chosen so that this modules search functions are faster, or possibly
even significantly faster, than <code>re</code>.</p>
      <h1 id="reference-implementation">
        
        
          Reference implementation <a href="#reference-implementation">#</a>
        
        
      </h1>
    

<p>A reference implementation was available on GitHub development branch 
before the final inclusion in R14A.</p>
      <h1 id="copyright">
        
        
          Copyright <a href="#copyright">#</a>
        
        
      </h1>
    

<p>This document is licensed under the <a href="http://creativecommons.org/licenses/by/3.0/" title="Creative Commons Attribution 3.0 License">Creative Commons license</a>.</p>

            </div>
        </div>
    </div>
</div>
<script src="/assets/js/prismjs/prism.js"></script>
<script src="/assets/js/prismjs/components/prism-erlang.js"></script>
    <footer class="container-fluid footer text-center border-top border-bottom">
        <div>
            <a href="/downloads.html" title="DOWNLOAD"><img src="/assets/img/download.png" alt="Download Erlang/OTP"></a>
        </div>
        <div>
            <a href="http://www.github.com/erlang/otp"><img
                    src="/assets/img/GitHub-Mark-32px.png" alt="Erlang/OTP on Github"></a>
        </div>
        
        <div>
            <a href="http://www.twitter.com/erlang_org"><img src="/assets/img/twitter.png"
                    width="32" alt="Erlang/OTP twitter"></a>
        </div>
    </footer>
    <script src="/assets/js/bootstrap/dist/js/bootstrap.bundle.min.js"></script>
</body>

</html>