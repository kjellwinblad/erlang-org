<!DOCTYPE html>
<html lang="en">



<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

    <!-- Allow pinning of website on windows -->
    <meta name="application-name" content="Erlang.org">
    <meta name="msapplication-tooltip" content="The official home of the Erlang Programming Language">
    <meta name="msapplication-starturl" content="/" >

    <!-- Make the site look nicer on facebook -->
    <meta property="og:type" content="website">
    <meta property="og:site_name" content="Erlang.org">
    <meta property="og:title" content="Welcome to Erlang.org">
    <meta property="og:description" content="The official home of the Erlang Programming Language">
    <meta property="og:image" content="https://beta.erlang.org/assets/img/erlang-228x200.png">
    <meta property="og:image:secure_url" content="https://beta.erlang.org/assets/img/erlang-228x200.png">
    <meta property="og:url" content="https://beta.erlang.org/">

    <!-- Twitter metadata -->
    <meta name="twitter:card" content="summary" />
    <meta property="twitter:title" content="Index" />
    <meta name="twitter:site" content="@erlang_org" />

    <!-- Rich data for google search -->
    <script type="application/ld+json">
{"@type":"WebSite","url":"https://erlang.org/","headline":"Eep 0032 - Erlang/OTP","name":"Erlang.org","sameAs":["https://twitter.com/erlang_org","https://github.com/erlang/otp"],"@context":"https://schema.org"}</script>

    <title>Eep 0032 - Erlang/OTP</title>

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- tells iOS browsers to not show telephone numbers as links -->
    <meta name="format-detection" content="telephone=no">

    <meta name="application-name" content="Erlang.org">
    <meta name="description" content="The official home of the Erlang Programming Language">
    <meta name="keywords" content="Erlang programming language functional parallel distributed documentation download community">
    <!-- https://www.rssboard.org/rss-autodiscovery -->
    <link rel="alternate" type="application/atom+xml" title="News Atom Feed" href="https://beta.erlang.org/news.xml" />
    <link rel="alternate" type="application/atom+xml" title="Blog Atom Feed" href="https://beta.erlang.org/blog.xml" />
    
    <link rel="stylesheet" href="/assets/css/main.css">
</head>

<body>
    <header class="navbar navbar-expand-lg navbar-light bg-body">
        <nav class="container">
            <button class="navbar-toggler" type="button" data-toggle="collapse" data-bs-toggle="collapse"
                data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false"
                aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <a class="navbar-brand" href="/"><img
                    src="/assets/img/erlang.png" class="img-fluid" width="60" alt="Erlang.org main page"/></a>
            <div class="collapse navbar-collapse fw-bold" id="navbarSupportedContent">
                <ul class="navbar-nav text-uppercase me-auto mb-2 mb-lg-0">
                    <li class="nav-item"><a class="nav-link" href="/downloads">Download</a></li>
                    <li class="nav-item"><a class="nav-link" href="/docs">Documentation</a></li>
                    <li class="nav-item"><a class="nav-link" href="/community">Community</a></li>
                    <li class="nav-item"><a class="nav-link" href="/news">News</a></li>
                    <li class="nav-item"><a class="nav-link" href="/blog">Blog</a></li>
                    <li class="nav-item"><a class="nav-link" href="/eep">EEP</a></li>
                    <li class="nav-item"><a class="nav-link" href="/about">About</a></li>
                </ul>
                <form class="d-flex" role="search" method="get" action="https://duckduckgo.com/">
                    <input type="hidden" name="sites" value="erlang.org">
                    <input class="form-control me-2" id="searchfield" name="q" type="search" placeholder="Search erlang.org"
                        aria-label="Search">
                    <button class="btn btn-outline-primary" type="submit">Search</button>
                </form>
            </div>
        </nav>
    </header>
    <div class="container border-top pt-4">
    <div class="row-lg">
        <div class="col-lg-10 offset-lg-1">
            <div class="card">
                <div class="card-body">
                    <dl class="mb-0 dl-single">
                        <dt>Author:</dt>
                        <dd>
                            Richard A. O&#39;Keefe &lt;ok(at)cs(dot)otago(dot)ac(dot)nz&gt;
                            
                            
                        </dd>
                        
                        <dt>Status:</dt>
                        <dd>Draft </dd>
                        <dt>Type:</dt>
                        <dd>Standards Track</dd>
                        
                        
                        <dt>Created:</dt>
                        <dd>09-Feb-2010</dd>
                        
                        <dt>Erlang-Version:</dt>
                        <dd>R13B-3</dd>
                        
                        
                        
                        
                    </dl>
                </div>
            </div>
            <div class="border-top mt-4">
                
                <h2 id="eep-32-module-local-process-names">
        
        
          EEP 32: Module-local process names <a href="#eep-32-module-local-process-names">#</a>
        
        
      </h2>
    
      <h1 id="abstract">
        
        
          Abstract <a href="#abstract">#</a>
        
        
      </h1>
    

<p>The process registry in Erlang is convenient, but counts as
a global shared mutable variable, with two major defects:
the possibility of data races (shared mutable variable) and
the impossibility of encapsulation (global).  This EEP
resurrects the old (1997 or earlier) proposal of module-
local process-valued variables, providing a replacement for
node-local uses of the registry with encapsulation and without
races.</p>
      <h1 id="specification">
        
        
          Specification <a href="#specification">#</a>
        
        
      </h1>
    

<p>A module (or an instance of a parameterized module) may have
one or more top level pid-valued variables, and if so, has a
lock associated with them.  The directive has the form</p>

<pre><code class="language-erlang">-pid_name(Atom).
</code></pre>

<p>where Atom is an atom.  To avoid confusing programmers who
still have to deal with the registry, this Atom may not be
‘undefined’.</p>

<p>If there is at least one such directive in a module, the
compiler automatically generates a function called
<code>pid_name/1</code>.  In the scope of directives</p>

<pre><code class="language-erlang">-pid_name(pn_1).
...
-pid_name(pn_k).
</code></pre>

<p>the <code>pid_name/1</code> function is rather like</p>

<pre><code class="language-erlang">pid_name(pn_1) -&gt;
    with_module_lock(read) -&gt; X = *pn_1 end, X;
...
pid_name(pn_k) -&gt;
    with_module_lock(read) -&gt; X = *pn_k end, X.
</code></pre>

<p>except that we expect there to be a VM instruction
<code>get_pid_safely(Address)</code>, and we expect the compiler to
inline calls to pid_name(Atom) when Atom is known.
On a machine like the <code>X86</code> or <code>X86_64</code>, this could be a
single locked load instruction.</p>

<p>The value of a <code>-pid_name</code> is always a process id.  <br />
There is a special process id value which at all times represents
a dead process.  So within a module,</p>

<pre><code class="language-erlang">pid_name(X) ! Message
</code></pre>

<p>is legal if and only if X is one of the pid-names declared in
the module, and whether or not the process it names has died.</p>

<p>If there is a need to discover whether a <code>-pid_name</code> has within
the recent but unpredictable past been associated with a live
process, that can be found out by combining <code>pid_name/1</code> with
<code>process_info/2</code>.</p>

<p>As with the registry, a process may have at most one <code>pid_name</code>.
For debugging purposes, I suppose that <code>process_info</code> could be
extended to return a <code>{pid_name,{Module,Name}}</code> tuple.</p>

<p>When a process exits, it is automatically unregistered.
That is, if it was bound to a <code>-pid_name</code>, that <code>-pid_name</code>
now refers to the conventional dead process.  This draft of
this EEP includes no other way for a process to be unregistered.</p>

<p>The important thing about registering a process is that it
should be atomic.  So there are two new functions</p>

<pre><code class="language-erlang">pid_name_spawn(Name, Fun)
pid_name_spawn_link(Name, Fun)
</code></pre>

<p>We can understand them as</p>

<pre><code class="language-erlang">pid_name_spawn(Name, Fun)
  when is_atom(Name), is_function(Fun, 0) -&gt;
    with_module_lock(write) -&gt;
	P = *Name,
	if P is a live process -&gt;
	    P
	 ; P is a dead process -&gt;
	    Q = spawn(Fun),
	    *Name := Q,
	    Q
	end
    end.

pid_name_spawn_link(Name, Fun)
  when is_atom(Name), is_function(Fun, 0) -&gt;
    with_module_lock(write) -&gt;
	P = *Name,
	if P is a live process -&gt;
	    P
	 ; P is a dead process -&gt;
	    Q = spawn(Fun),
	    *Name := Q,
	    Q
	end
    end.
</code></pre>

<p>Here, as earlier, <code>with_module_lock</code> is pseudo-code, meant to
suggest some sort of reader-writer locking on a private lock,
existing only inside a module that has declared a <code>-pid_name</code>.</p>

<p>These two functions are automatically declared inside the
module, like <code>pid_name/1</code>.  The three functions are not functions
automatically inherited from the <code>erlang:</code> module but functions
that are logically inside the module, however they might be
actually implemented.  There doesn’t seem to be any good
reason for a module to export any of these functions, and the
compiler should at least warn if that is attempted.</p>
      <h1 id="motivation">
        
        
          Motivation <a href="#motivation">#</a>
        
        
      </h1>
    

<ul>
  <li>
    <p>Encapsulation.</p>

    <p>The process registry is often used when clients of a module
need to communicate with one or more servers managed by the
module, but the interface code is inside the module.  There
is no advantage, and much risk, in exposing the process.  A
big reason for this process is to get the benefit of having
mutable process variables without the loss of encapsulation.</p>
  </li>
  <li>
    <p>Efficiency.</p>

    <p>As a shared mutable data structure, the registry has to be
accessed within the scope of suitable locks.  With this
approach, each module has its own lock, contention ought
to be pretty nearly zero, and the commonest use case of
the registry can, I believe, be a simple load instruction.</p>
  </li>
  <li>
    <p>Safety.</p>

    <p>It is actually surprisingly hard to register a process
safely, and the use of registered names is oddly inconsistent
with the use of direct process ids.  This interface is meant
to be simpler to use safely.</p>
  </li>
</ul>
      <h1 id="rationale">
        
        
          Rationale <a href="#rationale">#</a>
        
        
      </h1>
    

<p>The old Erlang book describes four functions for dealing with
registered process names.  There are two more main interfaces.</p>

<pre><code class="language-erlang">Name ! Message when is_atom(Name) -&gt;
  % Also available as erlang:send(Name, Message).
  % A 'badarg' exception results if Pid is an atom that is
  % not the registered name of a live local process or port.
    whereis(Name) ! Message.

register(Name, Pid) when is_atom(Name), is_pid(Pid) -&gt;
  % A 'badarg' exception results if Pid is not a live local
  % process or port, if Name is not an atom or is already in
  % use, if Pid already has a registered name, or if Name is
  % 'undefined'.
    "whereis(Name) := Pid".

unregister(Name) when is_atom(Name) -&gt;
  % A 'badarg' exception results if Name is not an atom
  % currently in use as the registered name of some process
  % or port.  'undefined' is always an error.
    "whereis(Name) := undefined".

whereis(Name) when is_atom(Name) -&gt;
  % A 'badarg' exception results if Name is not a name.
  % in effect, a global mutable hash table with
  % atom keys and pid-or-'undefined' values.

registered() -&gt;
    % yes, I know this is not executable Erlang.
    [Name || is_atom(Name), is_pid(whereis(Name))].

process_info(Pid, registered_name) when is_pid(Pid) -&gt;
    % yes, I know this is not executable Erlang.
    case [Name || is_atom(Name), whereis(Name) =:= Pid]
      of [N] -&gt; {registered_name,N}
       ; []  -&gt; []
    end.
</code></pre>

<p>When a process terminates, for whatever reason, it does the
equivalent of</p>

<pre><code class="language-erlang">case process_info(self(), registered_name)
  of {_,Name} -&gt; unregister(Name)
   ; []       -&gt; ok
end.
</code></pre>

<p>This has an astonishing consequence.</p>

<p>Suppose I do</p>

<pre><code class="language-erlang">Pid = spawn(Fun),
...
Pid ! Message
</code></pre>

<p>and between the time the process was created and the time I send
the message to it, the process dies.  In Erlang this is
perfectly ok, and the message just disappears.</p>

<p>Now suppose I do</p>

<pre><code class="language-erlang">register(Name, spawn(Fun)),
...
Name ! Message
</code></pre>

<p>and between the time the process was created and the time I send
the message to it, the process dies.  Anyone would expect the
result to be exactly the same: because the <code>Name</code> pointed to a
process which has died, this amounts to sending a message to a
dead process, which is perfectly ok, and the message just
disappears.  Most confusingly, that is not what happens, and
instead you get a ‘badarg’ exception.</p>

<p>Now suppose I do</p>

<pre><code class="language-erlang">send(Pid, Message) when is_pid(Pid) -&gt;
    Pid ! Message;
send(Name, Message) when is_atom(Name) -&gt;
    case whereis(Name)
      of undefined -&gt; ok
       ; Pid when is_pid(Pid) -&gt; Pid ! Message
    end.
...
    register(Name, spawn(Fun)),
    ...
    send(Name, Message)
</code></pre>

<p>This works the way we would expect, but why is it necessary?</p>

<p>In Erlang as it stands, <code>Name ! Message</code> will raise an error if
<code>Name</code> would have referred to the right process but that process
has died.  It might be argued that this is a useful debugging
aid, but nothing helps us if <code>Name</code> now refers to the WRONG
process.  Right now, consider</p>

<pre><code class="language-erlang">whereis(Name) ! Message
</code></pre>

<p>This will raise an exception if the named process had died
before whereis/1 was called, but consider this timing:</p>

<pre><code class="language-erlang">live           dies
   whereis runs      message sent
</code></pre>

<p>A slight change in timing can unpredictably change the
behaviour from silence-on-late-death to error-on-early-death
and vice versa.</p>

<pre><code class="language-erlang">pid_name(Name) ! Message
</code></pre>

<p>is <em>consistently</em> silent.</p>

<p>The current process registry is also used for ports, which act in
many ways like processes.</p>

<p>The old Erlang book is absolutely right that sometimes you
need a way to talk to a process you haven’t been previously
introduced to.  However, it is not true that this must be
done by means of a global hash table.  You could always ask
a module for the information.</p>

<p>Let’s take program 5.5 from the book.</p>

<pre><code class="language-erlang">-module(number_analyser). 
-export([start/0,server/1]). 
-export([add_number/2,analyse/1]). 

start() -&gt; 
    register(number_analyser, 
	spawn(number_analyser, server, [nil])). 

%% The interface functions. 

add_number(Seq, Dest) -&gt; 
    request({add_number,Seq,Dest}). 

analyse(Seq) -&gt; 
    request({analyse,Seq}). 

request(Req) -&gt; 
    number_analyser ! {self(), Req}, 
    receive 
	{number_analyser,Reply} -&gt; 
            Reply 
    end. 

%% The server. 

server(Analyser_Table) -&gt; 
    receive 
        {From, {analyse, Seq}} -&gt; 
	    Result = lookup(Seq, Analyser_Table), 
	    From ! {number_analyser, Result}, 
	    server(Analyser_Table)
      ; {From, {add_number, Seq, Dest}} -&gt; 
	    From ! {number_analyser, ack}, 
	    server(insert(Seq, Dest, Analyser_Table)) 
    end. 
</code></pre>

<p>The first thing we notice about this is that the registry is used
to allow a process that is a client of this module to communicate
with a process managed by this module through interface functions
in this module.  There is no reason why the process should be
given a GLOBALLY visible name, and every reason why it should NOT.
We would like to ensure that all communication with the server
process goes through the interface functions, and as long as the
process is in a global registry, anything could happen.  The
global process registry thus defeats its own purpose.</p>

<p>Similarly, because the reply messages to the interface functions
are tagged, not with the server’s identity, but with its public
name, they are easy to forge.  Both of these problems also apply
to Program 5.6 in the old book.</p>

<p>But there is worse.  It is NEVER safe to call <code>register/2</code> or
<code>unregister/1</code>.  Recall that the precondition for <code>register/2</code>
requires that the <code>Name</code> not be in use.  But there is no way to
ever be sure of that.  For example, you might try</p>

<pre><code class="language-erlang">spawn_if_necessary(Name, Fun) -&gt;
    case whereis(Name)		% T1
      of undefined -&gt;
	 Pid = spawn(Fun),	% T2
	 register(Name, Pid)	% T3
       ; Pid when is_pid(Pid) -&gt;
         ok
    end,
    Pid.
</code></pre>

<p>Unfortunately, between time T1, when <code>whereis/1</code> reports that the
<code>Name</code> is not in use, and time T3, when we try to assign it, some
other process might have been registered.  Also, between time T2,
when the new process is created, and T3, when we use the <code>Pid</code>, the
process might have died.</p>

<p>Because the registry is global, it is no use searching existing
code to see whether the <code>Name</code> is clobbered; the bug might be
introduced in future code.</p>

<p>There appears to be no way to protect against the possibility of a
process dying between T2 and T3.  The obvious hack,</p>

<pre><code class="language-erlang">Pid = spawn(Fun),
erlang:suspend_process(Pid),
register(Name, Pid),
erlang:resume_process(Pid)
</code></pre>

<p>won’t work because <code>erlang:suspend_process/1</code> is documented as
having the same ‘badarg if Pid is not the pid of a live local
process’ snafu as <code>register/2</code>.  The only really safe way around the
issue would be for the new process to be born suspended, and
there’s no way to do that.  There is no ‘suspended’ option allowed
in the options list of <code>spawn_opt/[2-5]</code>.</p>

<p>In practice, of course, the new process WON’T die, typically
because it goes into a loop waiting for a message.  Even so, this
amount of fragility in a primitive is a bit worrying.</p>

<p>Let’s take a quick check to see how real all this is.</p>

<p><code>sounder.erl</code> has</p>

<pre><code class="language-erlang">start() -&gt;
    case whereis(sounder) of
        undefined -&gt;
    	case file:read_file_info('/dev/audio') of
    	    {ok, FI} when FI#file_info.access==read_write -&gt;
    		register(sounder, spawn(sounder,go,[])),
    		ok;
    	    _Other -&gt;
    		register(sounder, spawn(sounder,nosound,[])),
    		silent
    	end;
        _Pid -&gt;
    	ok
    end.
</code></pre>

<p>Here’s a curious thing:  the first time <code>sounder:start/0</code> is
called, it will return different values (ok, silent) depending
on whether sound (is, is not) supported.  Later calls always
return ok.  This contradicts the documentation.  Whoops!
Apart from that, it’s a straightforward <code>spawn_if_necessary</code>.</p>

<p><code>man.erl</code> has</p>

<pre><code class="language-erlang">start() -&gt;
    case whereis(man) of
        undefined -&gt;
    	register(man,Pid=spawn(man,init,[])),
    	Pid;
        Pid -&gt;
    	Pid
    end.
</code></pre>

<p>This is precisely</p>

<pre><code class="language-erlang">start() -&gt; spawn_if_necessary(fun () -&gt; man:init() end).
</code></pre>

<p><code>tv_table_owner</code> has</p>

<pre><code class="language-erlang">start() -&gt;
    case whereis(?REGISTERED_NAME) of
        undefined -&gt;
    	ServerPid = spawn(?MODULE, init, []),
    	case catch register(?REGISTERED_NAME, ServerPid) of
    	    true -&gt;
    		ok;
    	    {'EXIT', _Reason} -&gt;
    		exit(ServerPid, kill),
    		timer:sleep(500),
    		start()
    	end;
        Pid when is_pid(Pid) -&gt;
    	ok
    end.
</code></pre>

<p>Let’s repackage that to see what’s going on:</p>

<pre><code class="language-erlang">spawn_if_necessary(Name, Fun) -&gt;
    case whereis(Name)
      of undefined -&gt;
         Pid = spawn(Fun),		    
         case catch register(Name, Pid)
           of true -&gt;
              Pid
            ; {'EXIT', _} -&gt;
              exit(Pid, kill),
              timer:sleep(500),
              spawn_if_necessary(Name, Fun)
         end
       ; Pid when is_pid(Pid) -&gt;
	 ok
    end.
</code></pre>

<p>If there is a live local process registered under <code>Name</code>, return its
<code>Pid</code>.  Of course, after the function returns to believe that there
is STILL a live local process registered under Name, but that’s
just as true of <code>whereis/1</code>.</p>

<p>If there is not, then create a new process, regardless of whether
that turns out to be useful.  Try to register it.  The <code>Pid</code> will be
the pid of a live local process that is not registered under any
other name, and <code>Name</code> must be an atom other than ‘undefined’, or
<code>whereis/1</code> would have crashed.  So it should be that the only thing
that can go wrong is that some other process has snuck in and
swiped the registry slot.  In that case, kill the process, wait a
long time, and try again.</p>

<p>In theory, it is possible for this to loop forever, with just the
right malevolent timing by an adversary.  In practice, I’m sure it
works very well.</p>

<p>The thing is, if the ‘primitives’ are this fragile, I would rather
not expose beginners to them.  Or for that matter, most people:
there are plenty of uses of <code>register/1</code> in the Erlang/OTP sources
that are not this well protected.</p>

<p>The simplest fix to the ‘registration race’ problem would be to
verify that <code>spawn_if_necessary/2</code> is sound, correct it if
necessary, and put it in a library.  However, that does nothing to
fix the globality of the registry.</p>

<p>There is no analogue of registered().  Inside a module, you can
see what names are available; outside the module, you have no
right to know.</p>

<p>This EEP does not propose abolishing the old registry.  There
is a lot of code, and a lot of training material, that still
uses or mentions it.  Above all, the old registry can do one
thing that this EEP cannot do and isn’t meant to, and that is
to provide names that can be used in other nodes, in <code>{Node,Name}</code>
form.  The aim of this proposal is to provide something that can
replace MOST uses of the registry with something safer, and in
particular to allow gradual migration to per-module registration.</p>
      <h1 id="backwards-compatibility">
        
        
          Backwards Compatibility <a href="#backwards-compatibility">#</a>
        
        
      </h1>
    

<p>The only modules that are affected by the new feature are
those that visibly contain an explicit <code>-pid_name</code> directive.</p>
      <h1 id="reference-implementation">
        
        
          Reference Implementation <a href="#reference-implementation">#</a>
        
        
      </h1>
    

<p>None.</p>
      <h1 id="example">
        
        
          Example <a href="#example">#</a>
        
        
      </h1>
    

<p>Here is the old book’s Program 5.5 again, brought up to date.</p>

<pre><code class="language-erlang">-module(number_analyser). 
-export([
    add_number/2,
    analyse/1,
    start/0,
    stop/0
 ]).
-pid_name(server).

start() -&gt;
    pid_name_spawn(server, fun () -&gt; server(nil) end).

stop() -&gt;
    pid_name(server) ! stop.

add_number(Seq, Dest) -&gt;
    request({add_number,Seq,Dest}).

analyse(Seq) -&gt;
    request({analyse,Seq}).

request(Request) -&gt;
    P = pid_name(server),
    P ! {self(), Request},
    receive {P,Reply} -&gt; Reply end.

server(Analyser_Table) -&gt;
    receive 
        {From, {analyse, Seq}} -&gt; 
	    From ! {self(), lookup(Seq, Analyser_Table)},
	    server(Analyser_Table)
      ; {From, {add_number, Seq, Dest}} -&gt; 
	    From ! {self(), ok}, 
	    server(insert(Seq, Dest, Analyser_Table)) 
    end. 
</code></pre>

<ul>
  <li>
    <p>It is now possible to use a programming convention where the
<code>-pid_name</code> of every server is ‘server’.</p>
  </li>
  <li>
    <p>It is no longer possible for code outside the module to send
messages to the server process.</p>
  </li>
  <li>
    <p>It is no longer possible (well, no longer embarrassingly easy)
for an outsider to forge responses from the server.</p>
  </li>
</ul>
      <h1 id="copyright">
        
        
          Copyright <a href="#copyright">#</a>
        
        
      </h1>
    

<p>This document has been placed in the public domain.</p>

            </div>
        </div>
    </div>
</div>
<script src="/assets/js/prismjs/prism.js"></script>
<script src="/assets/js/prismjs/components/prism-erlang.js"></script>
    <footer class="container-fluid footer text-center border-top border-bottom">
        <div>
            <a href="/downloads.html" title="DOWNLOAD"><img src="/assets/img/download.png" alt="Download Erlang/OTP"></a>
        </div>
        <div>
            <a href="http://www.github.com/erlang/otp"><img
                    src="/assets/img/GitHub-Mark-32px.png" alt="Erlang/OTP on Github"></a>
        </div>
        
        <div>
            <a href="http://www.twitter.com/erlang_org"><img src="/assets/img/twitter.png"
                    width="32" alt="Erlang/OTP twitter"></a>
        </div>
    </footer>
    <script src="/assets/js/bootstrap/dist/js/bootstrap.bundle.min.js"></script>
</body>

</html>