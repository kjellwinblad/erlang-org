<!DOCTYPE html>
<html lang="en">



<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

    <!-- Allow pinning of website on windows -->
    <meta name="application-name" content="Erlang.org">
    <meta name="msapplication-tooltip" content="The official home of the Erlang Programming Language">
    <meta name="msapplication-starturl" content="/" >

    <!-- Make the site look nicer on facebook -->
    <meta property="og:type" content="website">
    <meta property="og:site_name" content="Erlang.org">
    <meta property="og:title" content="Welcome to Erlang.org">
    <meta property="og:description" content="The official home of the Erlang Programming Language">
    <meta property="og:image" content="https://beta.erlang.org/assets/img/erlang-228x200.png">
    <meta property="og:image:secure_url" content="https://beta.erlang.org/assets/img/erlang-228x200.png">
    <meta property="og:url" content="https://beta.erlang.org/">

    <!-- Twitter metadata -->
    <meta name="twitter:card" content="summary" />
    <meta property="twitter:title" content="Index" />
    <meta name="twitter:site" content="@erlang_org" />

    <!-- Rich data for google search -->
    <script type="application/ld+json">
{"@type":"WebSite","url":"https://erlang.org/","headline":"Eep 0052 - Erlang/OTP","name":"Erlang.org","sameAs":["https://twitter.com/erlang_org","https://github.com/erlang/otp"],"@context":"https://schema.org"}</script>

    <title>Eep 0052 - Erlang/OTP</title>

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- tells iOS browsers to not show telephone numbers as links -->
    <meta name="format-detection" content="telephone=no">

    <meta name="application-name" content="Erlang.org">
    <meta name="description" content="The official home of the Erlang Programming Language">
    <meta name="keywords" content="Erlang programming language functional parallel distributed documentation download community">
    <!-- https://www.rssboard.org/rss-autodiscovery -->
    <link rel="alternate" type="application/atom+xml" title="News Atom Feed" href="https://beta.erlang.org/news.xml" />
    <link rel="alternate" type="application/atom+xml" title="Blog Atom Feed" href="https://beta.erlang.org/blog.xml" />
    
    <link rel="stylesheet" href="/assets/css/main.css">
</head>

<body>
    <header class="navbar navbar-expand-lg navbar-light bg-body">
        <nav class="container">
            <button class="navbar-toggler" type="button" data-toggle="collapse" data-bs-toggle="collapse"
                data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false"
                aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <a class="navbar-brand" href="/"><img
                    src="/assets/img/erlang.png" class="img-fluid" width="60" alt="Erlang.org main page"/></a>
            <div class="collapse navbar-collapse fw-bold" id="navbarSupportedContent">
                <ul class="navbar-nav text-uppercase me-auto mb-2 mb-lg-0">
                    <li class="nav-item"><a class="nav-link" href="/downloads">Download</a></li>
                    <li class="nav-item"><a class="nav-link" href="/docs">Documentation</a></li>
                    <li class="nav-item"><a class="nav-link" href="/community">Community</a></li>
                    <li class="nav-item"><a class="nav-link" href="/news">News</a></li>
                    <li class="nav-item"><a class="nav-link" href="/blog">Blog</a></li>
                    <li class="nav-item"><a class="nav-link" href="/eep">EEP</a></li>
                    <li class="nav-item"><a class="nav-link" href="/about">About</a></li>
                </ul>
                <form class="d-flex" role="search" method="get" action="https://duckduckgo.com/">
                    <input type="hidden" name="sites" value="erlang.org">
                    <input class="form-control me-2" id="searchfield" name="q" type="search" placeholder="Search erlang.org"
                        aria-label="Search">
                    <button class="btn btn-outline-primary" type="submit">Search</button>
                </form>
            </div>
        </nav>
    </header>
    <div class="container border-top pt-4">
    <div class="row-lg">
        <div class="col-lg-10 offset-lg-1">
            <div class="card">
                <div class="card-body">
                    <dl class="mb-0 dl-single">
                        <dt>Author:</dt>
                        <dd>
                            Bj√∂rn Gustavsson &lt;bjorn(at)erlang(dot)org&gt;
                            
                            
                        </dd>
                        
                        <dt>Status:</dt>
                        <dd>Accepted/23.0 Proposal is to be implemented in OTP release 23.0</dd>
                        <dt>Type:</dt>
                        <dd>Standards Track</dd>
                        
                        
                        <dt>Created:</dt>
                        <dd>28-Jan-2020</dd>
                        
                        <dt>Erlang-Version:</dt>
                        <dd>23</dd>
                        
                        
                        <dt>Post-History:</dt>
                        <dd>28-Jan-2020</dd>
                        
                        
                        
                    </dl>
                </div>
            </div>
            <div class="border-top mt-4">
                
                <h2 id="eep-52-allow-key-and-size-expressions-in-map-and-binary-matching">
        
        
          EEP 52: Allow key and size expressions in map and binary matching <a href="#eep-52-allow-key-and-size-expressions-in-map-and-binary-matching">#</a>
        
        
      </h2>
    
      <h1 id="abstract">
        
        
          Abstract <a href="#abstract">#</a>
        
        
      </h1>
    

<p>This EEP proposes an extension to matching of binaries to allow the
size of a segment to be a guard expression and to the matching of maps
to allow the key to be a guard expression.</p>
      <h1 id="specification">
        
        
          Specification <a href="#specification">#</a>
        
        
      </h1>
    

<p>We propose that in binary matching the size of a binary segment can be
a guard expression.  Here is an example:</p>

<pre><code class="language-erlang">example1(&lt;&lt;Size:8,Payload:((Size-1)*8)/binary,Rest/binary&gt;&gt;) -&gt;
   {Payload,Rest}.
</code></pre>

<p>The same expressions as in guards are allowed, except that the
old-style type tests (such a <code>list/1</code> or <code>tuple/1</code>) are not
allowed.  Unless the expression consists of a single number or single
variable is must be enclosed in parentheses.  Any variables used in the
expression must have been previously bound, or become bound in the
same binary pattern as the expression.  That is, the following example
is illegal:</p>

<pre><code class="language-erlang">illegal_example2(N, &lt;&lt;X:N,T/binary&gt;&gt;) -&gt;
    {X,T}.
</code></pre>

<p>A binary pattern will fail to match, if size expression in any of its
segments does not evaluate successfully or evaluates to a non-integer
value.  For example:</p>

<pre><code class="language-erlang">example3(&lt;&lt;X:(1/0)&gt;&gt;) -&gt; X;
example3(&lt;&lt;X:not_integer&gt;&gt;) -&gt; X;
example3(_) -&gt; no_match.
</code></pre>

<p>The first clause will not match because the evaluation of <code>1/0</code> fails.
The second clause will not match because the size evaluates to an atom.</p>

<p>In the current map matching syntax, the keys in a map pattern must be
a single value or a literal.  That leads to unnatural code if the keys
in a map are complex terms.  For example:</p>

<pre><code class="language-erlang">example4(M, X) -&gt;
    Key = {tag,X},
    #{Key := Value} = M,
    Value.
</code></pre>

<p>We propose that the key in a map pattern can be a guard expression.
That will allow the previous example to be written like this:</p>

<pre><code class="language-erlang">example5(M, X) -&gt;
    #{{tag,X} := Value} = M,
    Value.
</code></pre>

<p>All variables used in a key expression must be previously bound.
Thus, the following example is illegal:</p>

<pre><code class="language-erlang">illegal_example6(Key, #{Key := Value}) -&gt; Value.
</code></pre>
      <h1 id="motivation">
        
        
          Motivation <a href="#motivation">#</a>
        
        
      </h1>
    

<p>The current limitations of map keys are surprising.  A literal tuple
such as <code>{a,b}</code> is allowed as a key, while a tuple with a variable
such as <code>{a,Var}</code> is not.</p>

<p>In binary matching, it has always been possible to multiply a matched
out number by  a small constant using the <code>unit:</code> modifier.  The proposed
extension makes is possible in more circumstances to match both header
and payload in the same binary pattern.</p>
      <h1 id="rationale">
        
        
          Rationale <a href="#rationale">#</a>
        
        
      </h1>
    
      <h2 id="why-allow-guard-expressions">
        
        
          Why allow guard expressions? <a href="#why-allow-guard-expressions">#</a>
        
        
      </h2>
    

<p>We did consider only allowing term construction and expressions using
arithmetic operators.  There are two reasons we went with guard
expression instead:</p>

<ul>
  <li>
    <p>It is easy to explain and understand exactly what expression are
allowed as segment sizes and as map keys, because the same type of
expressions are allowed in guards.</p>
  </li>
  <li>
    <p>When calculating the size of binary segment, a subset of guard BIFs
could conceivable be useful in practice.  For example: <code>ceiling/1</code>,
<code>round/1</code>, <code>byte_size/1</code>, <code>bit_size/1</code>, and <code>map_get/2</code>.  We did not
want an arbitrary list of allowed BIFs in size expressions, so the
only logical thing is to allow full guard expressions.</p>
  </li>
</ul>
      <h2 id="why-are-not-absurd-size-expressions-compilation-errors">
        
        
          Why are not absurd size expressions compilation errors? <a href="#why-are-not-absurd-size-expressions-compilation-errors">#</a>
        
        
      </h2>
    

<p>Size expressions that obviously never evaluates to an integer will
not cause a compilation error (but may cause a warning).  For example:</p>

<pre><code class="language-erlang">example6(Bin, V) -&gt;
    &lt;&lt;X:(is_list(V))&gt;&gt; = Bin,
    X.
</code></pre>

<p>The reason is that rules for what is a legal Erlang program should be
simple and unambiguous, to help both people and tools that generate
Erlang programs.</p>
      <h2 id="why-are-parentheses-required-around-non-trivial-size-expressions">
        
        
          Why are parentheses required around non-trivial size expressions? <a href="#why-are-parentheses-required-around-non-trivial-size-expressions">#</a>
        
        
      </h2>
    

<p>For the same reason that they are required when constructing binaries,
namely that language grammar would be ambiguous without the
parentheses, since binary patterns use the characters <code>:</code>, <code>/</code>, and
<code>-</code> with a different meaning than in the rest of the language.</p>
      <h1 id="backwards-compatibility">
        
        
          Backwards Compatibility <a href="#backwards-compatibility">#</a>
        
        
      </h1>
    

<p>Using the extended expressions segment size and map keys would cause a
compilation error in OTP 22 and previous releases.  Therefore, no
existing source code can be affected.</p>

<p>However, there are changes to the semantics of Core Erlang that may
make it necessary to update languages compilers or tools that generate
Core Erlang code.</p>

<p>There are two major changes:</p>

<ul>
  <li>
    <p>A binary pattern in Core Erlang is no longer allowed to bind and use
a variable in the same binary pattern.</p>
  </li>
  <li>
    <p>To fully support binary matching in receives, receives must be lowered
to more primitive operations.</p>
  </li>
</ul>
      <h2 id="binary-matching-in-core-erlang">
        
        
          Binary matching in Core Erlang <a href="#binary-matching-in-core-erlang">#</a>
        
        
      </h2>
    

<p>In Erlang, a variable can be bound in a binary pattern and used later
in the same pattern as the size of a segment:</p>

<pre><code class="language-erlang">foo(&lt;&lt;Sz:16,X:Sz&gt;&gt;) -&gt; X.
</code></pre>

<p>In OTP 22 and previous releases, the translation to Core Erlang is
straightforward:</p>

<pre><code class="language-erlang">'foo'/1 =
    fun (_0) -&gt;
        case _0 of
          &lt;#{#&lt;Sz&gt;(16,1,'integer',['unsigned'|['big']]),
             #&lt;X&gt;(Sz,1,'integer',['unsigned'|['big']])}#&gt; when 'true' -&gt;
              X
          &lt;_1&gt; when 'true' -&gt;
              %% Raise function_clause exception.
              .
              .
              .
        end
</code></pre>

<p>While the translation is straightforward, all Core Erlang passes would need
to handle binding and using a variable in the same scope.  That would become
even more complicated if we were to allow expressions as segment sizes.</p>

<p>In OTP 23, all variables used in a segment size expression must be already
bound in the enclosing environment.  The previous example must be rewritten
like this using nested cases:</p>

<pre><code class="language-erlang">'foo'/1 =
    fun (_0) -&gt;
          case _0 of
              &lt;#{#&lt;Sz&gt;(16,1,'integer',['unsigned'|['big']]),
               #&lt;_2&gt;('all',1,'binary',['unsigned'|['big']])}#&gt; when 'true' -&gt;
                  case _2 of
                     &lt;#{#&lt;X&gt;(Sz,1,'integer',['unsigned'|['big']])}#&gt; when 'true' -&gt;
                         X
                     &lt;_3&gt; when 'true' -&gt;
                         %% Raise function_clause exception.
                         .
                         .
                         .
                    end
               &lt;_4&gt; when 'true' -&gt;
                    %% Raise function_clause exception.
                    .
                    .
                    .
              end
</code></pre>

<p>However, as can be seen from the example, the code for raising the <code>function_clause</code>
exception has been duplicated.  The code duplication is no big deal in this simple
example, but it would be in a function where the binary matching clause was followed
by many other clauses.  To avoid the code duplication, we must use <code>letrec</code> with
the <code>letrec_goto</code> annotation:</p>

<pre><code class="language-erlang">'foo'/1 =
    fun (_0) -&gt;
        ( letrec
              'label^0'/0 =
                  fun () -&gt;
                        case _0 of
                          &lt;_1&gt; when 'true' -&gt;
                                %% Raise function_clause exception.
                                .
                                .
                                .
                        end
          in  case _0 of
                &lt;#{#&lt;Sz&gt;(16,1,'integer',['unsigned'|['big']]),
                   #&lt;_2&gt;('all',1,'binary',['unsigned'|['big']])}#&gt; when 'true' -&gt;
                    case _2 of
                      &lt;#{#&lt;X&gt;(Sz,1,'integer',['unsigned'|['big']])}#&gt; when 'true' -&gt;
                          X
                      &lt;_3&gt; when 'true' -&gt;
                            apply 'label^0'/0()
                    end
                &lt;_4&gt; when 'true' -&gt;
                      apply 'label^0'/0()
              end
          -| ['letrec_goto'] )
</code></pre>

<p>When a <code>letrec</code> has been given the annotation <code>letrec_goto</code>, it will be
specially translated.  The <code>apply</code> operations will be translated to a goto
instead of a call to a local function.</p>
      <h2 id="translating-receive-to-core-erlang">
        
        
          Translating receive to Core Erlang <a href="#translating-receive-to-core-erlang">#</a>
        
        
      </h2>
    

<p>Consider this example:</p>

<pre><code class="language-erlang">bar(Timeout) -&gt;
    receive
        {tag,Msg} -&gt; Msg
    after
        Timeout -&gt;
            no_message
    end.
</code></pre>

<p>In a OTP 22 and earlier, the translation to Core Erlang was straightforward:</p>

<pre><code class="language-erlang">'bar'/1 =
    fun (Timeout) -&gt;
        receive
          &lt;{'tag',Msg}&gt; when 'true' -&gt;
              Msg
        after Timeout -&gt;
          'no_message'
</code></pre>

<p>In order to fully support binary matching in OTP 23, a <code>receive</code> in Erlang
has now been lowered to more primitive operations in Core Erlang:</p>

<pre><code class="language-erlang">'foo'/1 =
    fun (Timeout) -&gt;
        ( letrec
              'recv$^0'/0 =
                  fun () -&gt;
                      let &lt;PeekSucceeded,Message&gt; =
                          primop 'recv_peek_message'()
                      in  case PeekSucceeded of
                            &lt;'true'&gt; when 'true' -&gt;
                                case Message of
                                  &lt;{'tag',Msg}&gt; when 'true' -&gt;
                                      do  primop 'remove_message'()
                                          Msg
                                  &lt;Other&gt; when 'true' -&gt;
                                      do  primop 'recv_next'()
                                            apply 'recv$^0'/0()
                                end
                            &lt;'false'&gt; when 'true' -&gt;
                                let &lt;TimedOut&gt; =
                                    primop 'recv_wait_timeout'(Timeout)
                                in  case TimedOut of
                                      &lt;'true'&gt; when 'true' -&gt;
                                          do  primop 'timeout'()
                                              'no_message'
                                      &lt;'false'&gt; when 'true' -&gt;
                                          apply 'recv$^0'/0()
                                    end
                          end
          in  apply 'recv$^0'/0()
          -| ['letrec_goto'] )
</code></pre>

<p>When compiling from Core Erlang code in OTP 23, the compiler will
accept Core Erlang code that uses the <code>receive</code> construct and
automatically lower it to the more primitive operations.  That is,
for the example above, the Core Erlang translation from OTP 22 will
be accepted as input to the compiler in OTP 23.</p>

<p>Here is another example where the Core Erlang code from OTP 22
will not be accepted.  Here is the Erlang code:</p>

<pre><code class="language-erlang">foobar() -&gt;
    receive
        &lt;&lt;Sz:16,X:Sz&gt;&gt; -&gt; X
    end.
</code></pre>

<p>In OTP 22, this would be translated to Core Erlang code like this:</p>

<pre><code class="language-erlang">'foobar'/0 =
    fun () -&gt;
        receive
          &lt;#{#&lt;Sz&gt;(16,1,'integer',['unsigned'|['big']]),
             #&lt;X&gt;(Sz,1,'integer',['unsigned'|['big']])}#&gt; when 'true' -&gt;
              X
        after 'infinity' -&gt;
          'true'
</code></pre>

<p>That translation will not be accepted by the compiler in OTP 23.  The <code>receive</code>
must be lowered to more primitive operations, and the binary matching must be
rewritten using nested cases:</p>

<pre><code class="language-erlang">'foobar'/0 =
    fun () -&gt;
        ( letrec
              'recv$^0'/0 =
                  fun () -&gt;
                      let &lt;_5,_0&gt; =
                          primop 'recv_peek_message'()
                      in  case _5 of
                            &lt;'true'&gt; when 'true' -&gt;
                                ( letrec
                                      'label^0'/0 =
                                          fun () -&gt;
                                                do  primop 'recv_next'()
                                                    apply 'recv$^0'/0()
                                  in  case _0 of
                                        &lt;#{#&lt;Sz&gt;(16,1,'integer',['unsigned'|['big']]),
                                           #&lt;_1&gt;('all',1,'binary',['unsigned'|['big']])}#&gt; when 'true' -&gt;
                                            case _1 of
                                              &lt;#{#&lt;X&gt;(Sz,1,'integer',['unsigned'|['big']])}#&gt; when 'true' -&gt;
                                                  do  primop 'remove_message'()
                                                      X
                                              &lt;_2&gt; when 'true' -&gt;
                                                    apply 'label^0'/0()
                                            end
                                        &lt;_3&gt; when 'true' -&gt;
                                              apply 'label^0'/0()
                                      end
                                  -| ['letrec_goto'] )
                            &lt;'false'&gt; when 'true' -&gt;
                                  let &lt;_4&gt; =
                                      primop 'recv_wait_timeout'
                                          ('infinity')
                                  in  case _4 of
                                        &lt;'true'&gt; when 'true' -&gt;
                                            do  primop 'timeout'()
                                                'true'
                                        &lt;'false'&gt; when 'true' -&gt;
                                            apply 'recv$^0'/0()
                                      end
                          end
          in apply 'recv$^0'/0() )
          -| ['letrec_goto']
</code></pre>
      <h1 id="implementation">
        
        
          Implementation <a href="#implementation">#</a>
        
        
      </h1>
    

<p>The implementation can be found in <a href="https://github.com/erlang/otp/pull/2521" title="#2521: Allow key and size expressions in map and binary matching">PR #2521</a>.</p>
      <h1 id="copyright">
        
        
          Copyright <a href="#copyright">#</a>
        
        
      </h1>
    

<p>This document has been placed in the public domain.</p>

            </div>
        </div>
    </div>
</div>
<script src="/assets/js/prismjs/prism.js"></script>
<script src="/assets/js/prismjs/components/prism-erlang.js"></script>
    <footer class="container-fluid footer text-center border-top border-bottom">
        <div>
            <a href="/downloads.html" title="DOWNLOAD"><img src="/assets/img/download.png" alt="Download Erlang/OTP"></a>
        </div>
        <div>
            <a href="http://www.github.com/erlang/otp"><img
                    src="/assets/img/GitHub-Mark-32px.png" alt="Erlang/OTP on Github"></a>
        </div>
        
        <div>
            <a href="http://www.twitter.com/erlang_org"><img src="/assets/img/twitter.png"
                    width="32" alt="Erlang/OTP twitter"></a>
        </div>
    </footer>
    <script src="/assets/js/bootstrap/dist/js/bootstrap.bundle.min.js"></script>
</body>

</html>