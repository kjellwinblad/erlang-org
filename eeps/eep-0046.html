<!DOCTYPE html>
<html lang="en">



<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

    <!-- Allow pinning of website on windows -->
    <meta name="application-name" content="Erlang.org">
    <meta name="msapplication-tooltip" content="The official home of the Erlang Programming Language">
    <meta name="msapplication-starturl" content="/" >

    <!-- Make the site look nicer on facebook -->
    <meta property="og:type" content="website">
    <meta property="og:site_name" content="Erlang.org">
    <meta property="og:title" content="Welcome to Erlang.org">
    <meta property="og:description" content="The official home of the Erlang Programming Language">
    <meta property="og:image" content="https://beta.erlang.org/assets/img/erlang-228x200.png">
    <meta property="og:image:secure_url" content="https://beta.erlang.org/assets/img/erlang-228x200.png">
    <meta property="og:url" content="https://beta.erlang.org/">

    <!-- Twitter metadata -->
    <meta name="twitter:card" content="summary" />
    <meta property="twitter:title" content="Index" />
    <meta name="twitter:site" content="@erlang_org" />

    <!-- Rich data for google search -->
    <script type="application/ld+json">
{"@type":"WebSite","url":"https://erlang.org/","headline":"Eep 0046 - Erlang/OTP","name":"Erlang.org","sameAs":["https://twitter.com/erlang_org","https://github.com/erlang/otp"],"@context":"https://schema.org"}</script>

    <title>Eep 0046 - Erlang/OTP</title>

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- tells iOS browsers to not show telephone numbers as links -->
    <meta name="format-detection" content="telephone=no">

    <meta name="application-name" content="Erlang.org">
    <meta name="description" content="The official home of the Erlang Programming Language">
    <meta name="keywords" content="Erlang programming language functional parallel distributed documentation download community">
    <!-- https://www.rssboard.org/rss-autodiscovery -->
    <link rel="alternate" type="application/atom+xml" title="News Atom Feed" href="https://beta.erlang.org/news.xml" />
    <link rel="alternate" type="application/atom+xml" title="Blog Atom Feed" href="https://beta.erlang.org/blog.xml" />
    
    <link rel="stylesheet" href="/assets/css/main.css">
</head>

<body>
    <header class="navbar navbar-expand-lg navbar-light bg-body">
        <nav class="container">
            <button class="navbar-toggler" type="button" data-toggle="collapse" data-bs-toggle="collapse"
                data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false"
                aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <a class="navbar-brand" href="/"><img
                    src="/assets/img/erlang.png" class="img-fluid" width="60" alt="Erlang.org main page"/></a>
            <div class="collapse navbar-collapse fw-bold" id="navbarSupportedContent">
                <ul class="navbar-nav text-uppercase me-auto mb-2 mb-lg-0">
                    <li class="nav-item"><a class="nav-link" href="/downloads">Download</a></li>
                    <li class="nav-item"><a class="nav-link" href="/docs">Documentation</a></li>
                    <li class="nav-item"><a class="nav-link" href="/community">Community</a></li>
                    <li class="nav-item"><a class="nav-link" href="/news">News</a></li>
                    <li class="nav-item"><a class="nav-link" href="/blog">Blog</a></li>
                    <li class="nav-item"><a class="nav-link" href="/eep">EEP</a></li>
                    <li class="nav-item"><a class="nav-link" href="/about">About</a></li>
                </ul>
                <form class="d-flex" role="search" method="get" action="https://duckduckgo.com/">
                    <input type="hidden" name="sites" value="erlang.org">
                    <input class="form-control me-2" id="searchfield" name="q" type="search" placeholder="Search erlang.org"
                        aria-label="Search">
                    <button class="btn btn-outline-primary" type="submit">Search</button>
                </form>
            </div>
        </nav>
    </header>
    <div class="container border-top pt-4">
    <div class="row-lg">
        <div class="col-lg-10 offset-lg-1">
            <div class="card">
                <div class="card-body">
                    <dl class="mb-0 dl-single">
                        <dt>Author:</dt>
                        <dd>
                            Walter Weinmann &lt;walter.weinmann@gmail.com&gt;
                            
                            
                        </dd>
                        
                        <dt>Status:</dt>
                        <dd>Draft </dd>
                        <dt>Type:</dt>
                        <dd>Standards Track</dd>
                        
                        
                        <dt>Created:</dt>
                        <dd>06-Dec-2016</dd>
                        
                        <dt>Erlang-Version:</dt>
                        <dd>OTP 20.0</dd>
                        
                        
                        <dt>Post-History:</dt>
                        <dd>6-Dec-2016</dd>
                        
                        
                        
                    </dl>
                </div>
            </div>
            <div class="border-top mt-4">
                
                <h2 id="eep-46-b-trees-balanced-search-trees-of-order-n">
        
        
          EEP 46: B-trees: balanced search trees of order n <a href="#eep-46-b-trees-balanced-search-trees-of-order-n">#</a>
        
        
      </h2>
    
      <h1 id="abstract">
        
        
          Abstract <a href="#abstract">#</a>
        
        
      </h1>
    

<p>This EEP proposes the creation of a new module named b_trees for the 
administration of b-trees.  Both the optional persistence and the sort 
order should be implemented by pluggable functionality.</p>
      <h1 id="copyright">
        
        
          Copyright <a href="#copyright">#</a>
        
        
      </h1>
    

<p>This document has been placed in the public domain.</p>
      <h1 id="specification">
        
        
          Specification <a href="#specification">#</a>
        
        
      </h1>
    
      <h2 id="data-structure">
        
        
          Data Structure <a href="#data-structure">#</a>
        
        
      </h2>
    

<pre><code class="language-erlang">{MinimumSubtrees, 
 MaximumKeys, 
 SizeKeyValues, 
 SortFunction/2, 
 State, 
 Tree}
</code></pre>

<p><code>Tree</code> is composed of nodes of the form</p>

<pre><code class="language-erlang">{KeyNumber, 
 SubtreeNumber, 
 [{Key, Value}], 
 [Tree]} 
</code></pre>

<p>and the “empty b-tree” node</p>

<pre><code class="language-erlang">nil
</code></pre>

<p><code>State</code> is a tuple composed of the following parameters:</p>

<pre><code class="language-erlang">{StateTarget, 
 DeleteFunction/3, 
 InsertFunction/3, 
 LookupFunction/3} 
</code></pre>

<p>Since the b-trees are always balanced, there is no need for a balance 
operation.</p>
      <h2 id="data-types">
        
        
          DATA TYPES <a href="#data-types">#</a>
        
        
      </h2>
    

<pre><code class="language-erlang">b_tree() = {pos_integer(), 
            pos_integer(), 
            non_neg_integer(), 
            sort_function(), 
            state(), 
            tree()}
</code></pre>

<p>A general balanced tree.</p>

<pre><code class="language-erlang">iterator() = [{key_values(), subtrees()}]
</code></pre>

<p>A general balanced tree iterator.</p>
      <h2 id="exports">
        
        
          EXPORTS <a href="#exports">#</a>
        
        
      </h2>
    
      <h3 id="copytree1-tree2---tree3">
        
        
          copy(Tree1, Tree2) -&gt; Tree3 <a href="#copytree1-tree2---tree3">#</a>
        
        
      </h3>
    

<p>Types:</p>

<pre><code class="language-erlang">Tree1 = Tree2 = Tree3 = b_tree() | gb_trees:tree()
</code></pre>

<p>Copies tree Tree1 to an empty tree Tree2. Both trees may be either 
of type b-tree or binary tree (gb_trees). Returns the new tree 
Tree3 of the same type as tree Tree2.</p>
      <h3 id="deletekey-b-tree1---b-tree2">
        
        
          delete(Key, B-Tree1) -&gt; B-Tree2 <a href="#deletekey-b-tree1---b-tree2">#</a>
        
        
      </h3>
    

<p>Types:</p>

<pre><code class="language-erlang">Key = any()
B-Tree1 = B-Tree2 = b_tree()
</code></pre>

<p>Removes the node with key Key from b-tree B-Tree1 and returns the new 
b-tree B-Tree2.  Assumes that key Key is present in b-tree B-Tree1, 
crashes otherwise.</p>
      <h3 id="delete_any-key-b-tree1---b-tree2">
        
        
          delete_any (Key, B-Tree1) -&gt; B-Tree2 <a href="#delete_any-key-b-tree1---b-tree2">#</a>
        
        
      </h3>
    

<p>Types:</p>

<pre><code class="language-erlang">Key = any()
B-Tree1 = B-Tree2 = b_tree()
</code></pre>

<p>Removes the node with key Key from b-tree B-Tree1 if key Key is present 
in b-tree B-Tree1, otherwise does nothing.  Returns the new b-tree B-Tree2.</p>
      <h3 id="empty-order---b-tree">
        
        
          empty (Order) -&gt; B-Tree <a href="#empty-order---b-tree">#</a>
        
        
      </h3>
    

<p>Types:</p>

<pre><code class="language-erlang">Order = pos_integer()
B-Tree = b_tree()
</code></pre>

<p>Returns a new empty b-tree.  The order is defined as the maximum number 
of children nodes a non-leaf node may hold.</p>
      <h3 id="enter-key-value-b-tree1---b-tree2">
        
        
          enter (Key, Value, B-Tree1) -&gt; B-Tree2 <a href="#enter-key-value-b-tree1---b-tree2">#</a>
        
        
      </h3>
    

<p>Types:</p>

<pre><code class="language-erlang">Key = any()
Value = any()
B-Tree1 = B-Tree2 = b_tree()
</code></pre>

<p>Inserts key Key with value Value into b-tree B-Tree1 if key Key is not 
present in b-tree B-Tree1, otherwise updates the current value of key Key 
to value Value in b-tree B-Tree1.  Returns a new b-tree B-Tree2.</p>
      <h3 id="from_dict-b-tree1-list---b-tree2">
        
        
          from_dict (B-Tree1, List) -&gt; B-Tree2 <a href="#from_dict-b-tree1-list---b-tree2">#</a>
        
        
      </h3>
    

<p>Types:</p>

<pre><code class="language-erlang">B-Tree1 = B-Tree2 = b_tree()
List = [{Key, Value}]
</code></pre>

<p>Turns an ordered list List of key value tuples into a b-tree.  The given 
b-tree B-Tree1 must be empty.  The list must not contain duplicate keys.</p>
      <h3 id="get-key-b-tree---value">
        
        
          get (Key, B-Tree) -&gt; Value <a href="#get-key-b-tree---value">#</a>
        
        
      </h3>
    

<p>Types:</p>

<pre><code class="language-erlang">Key = any()
B-Tree = b_tree()
Value = any()
</code></pre>

<p>Retrieves the value stored with key Key in b-tree B-Tree.  Assumes that 
key Key is present in b-tree B-Tree, crashes otherwise.</p>
      <h3 id="height-b-tree---integer--0">
        
        
          height (B-Tree) -&gt; integer() &gt;= 0 <a href="#height-b-tree---integer--0">#</a>
        
        
      </h3>
    

<p>Types:</p>

<pre><code class="language-erlang">B-Tree = b_tree()
</code></pre>

<p>Returns the height of b-tree B-Tree as an integer.  Assumes that b-tree 
B-Tree is non-empty.</p>
      <h3 id="insert-key-value-b-tree1---b-tree2">
        
        
          insert (Key, Value, B-Tree1) -&gt; B-Tree2 <a href="#insert-key-value-b-tree1---b-tree2">#</a>
        
        
      </h3>
    

<p>Types:</p>

<pre><code class="language-erlang">Key = any()
Value = any()
B-Tree1 = B-Tree2 = b_tree()
</code></pre>

<p>Inserts key Key with value Value into b-tree  B-Tree1 and returns the new 
b-tree B-Tree2.  Assumes that key Key is <strong>not</strong> present in b-tree B-Tree1, 
crashes otherwise.</p>
      <h3 id="is_defined-key-b-tree---boolean">
        
        
          is_defined (Key, B-Tree) -&gt; boolean() <a href="#is_defined-key-b-tree---boolean">#</a>
        
        
      </h3>
    

<p>Types:</p>

<pre><code class="language-erlang">Key = any()
B-Tree = b_tree()
</code></pre>

<p>Returns <code>true</code> if key Key is present in b-tree B-Tree, otherwise <code>false</code>.</p>
      <h3 id="is_empty-b-tree---boolean">
        
        
          is_empty (B-Tree) -&gt; boolean() <a href="#is_empty-b-tree---boolean">#</a>
        
        
      </h3>
    

<p>Types:</p>

<pre><code class="language-erlang">B-Tree = b_tree()
</code></pre>

<p>Returns <code>true</code> if b-tree B-Tree is an empty b-tree, otherwise <code>false</code>.</p>
      <h3 id="iterator-b-tree---iterator">
        
        
          iterator (B-Tree) -&gt; Iterator <a href="#iterator-b-tree---iterator">#</a>
        
        
      </h3>
    

<p>Types:</p>

<pre><code class="language-erlang">B-Tree = b_tree()
Iterator = iterator()
</code></pre>

<p>Returns iterator Iterator that can be used for traversing the entries 
of b-tree B-Tree; see <code>next/1</code>.  The implementation of this iterator is 
very efficient; traversing the whole b-tree using <code>next/1</code> is only slightly
slower than getting the list of all key-value pairs using <code>to_list/1</code> 
and traversing that.  The main advantage of the iterator approach is that 
it does not require the complete list of all key-value pairs to be built 
in memory at one time.</p>
      <h3 id="iterator_from-key-b-tree---iterator">
        
        
          iterator_from (Key, B-Tree) -&gt; Iterator <a href="#iterator_from-key-b-tree---iterator">#</a>
        
        
      </h3>
    

<p>Types:</p>

<pre><code class="language-erlang">Key = any(9
B-Tree = b_tree()
Iterator = iterator()
</code></pre>

<p>Returns iterator Iterator that can be used for traversing the entries 
of b-tree B-Tree; see <code>next/1</code>.  The difference, as compared to the 
iterator returned by iterator/1, is that the first key greater than 
or equal to key Key is returned.</p>
      <h3 id="keys-b-tree---key">
        
        
          keys (B-Tree) -&gt; [Key] <a href="#keys-b-tree---key">#</a>
        
        
      </h3>
    

<p>Types:</p>

<pre><code class="language-erlang">B-Tree = b_tree()
Key = any()
</code></pre>

<p>Returns the keys in b-tree B-Tree as an ordered list.</p>
      <h3 id="largest-b-tree---key-value">
        
        
          largest (B-Tree) -&gt; {Key, Value} <a href="#largest-b-tree---key-value">#</a>
        
        
      </h3>
    

<p>Types:</p>

<pre><code class="language-erlang">B-Tree = b_tree()
Key = any()
Value = any()
</code></pre>

<p>Returns a tuple {Key, Value}, where Key is the largest key in b-tree 
B-Tree, and Value is the value associated with this key.  Assumes that 
b-tree B-Tree is not empty.</p>
      <h3 id="lookup-key-b-tree---none--value-value">
        
        
          lookup (Key, B-Tree) -&gt; none | {value, Value} <a href="#lookup-key-b-tree---none--value-value">#</a>
        
        
      </h3>
    

<p>Types:</p>

<pre><code class="language-erlang">Key = any()
B-Tree = b_tree()
Value = any()
</code></pre>

<p>Looks up key Key in b-tree B-Tree. Returns {value, Value}, or none if 
key Key is not present.</p>
      <h3 id="map-function-b-tree1---b-tree2">
        
        
          map (Function, B-Tree1) -&gt; B-Tree2 <a href="#map-function-b-tree1---b-tree2">#</a>
        
        
      </h3>
    

<p>Types:</p>

<pre><code class="language-erlang">Function = fun((Key, Value1) -&gt; Value2)
B-Tree1 = B-Tree2 = b_tree()
Key = any()
Value1 = Value2 = any()
</code></pre>

<p>Maps function Function(Key, Value1) -&gt; Value2 to all key value pairs of 
b-tree B-Tree1.  Returns the new b-tree B-Tree2 with the same set of 
keys as b-tree B-Tree1 and the new set of values.</p>
      <h3 id="next-iterator1---none--key-value-iterator2">
        
        
          next (Iterator1) -&gt; ‘none’ | {Key, Value, Iterator2} <a href="#next-iterator1---none--key-value-iterator2">#</a>
        
        
      </h3>
    

<p>Types:</p>

<pre><code class="language-erlang">Iterator1 = Iterator2 = iterator()
Key = any()
Value = any()
</code></pre>

<p>Returns the tuple {Key, Value, Iterator2}, where Key is the smallest 
key referred to by iterator Iterator1, and iterator Iterator2 is the 
new iterator to be used for traversing the remaining nodes, or the 
atom ‘<strong>none</strong>’ if no nodes remain.</p>
      <h3 id="set_parameter-b-tree1-name-value---b-tree2">
        
        
          set_parameter (B-Tree1, Name, Value) -&gt; B-Tree2 <a href="#set_parameter-b-tree1-name-value---b-tree2">#</a>
        
        
      </h3>
    

<p>Types:</p>

<pre><code class="language-erlang">B-Tree1 = B-Tree2 = b_tree()
Name : Value = sort  : Function = fun((Key1, Key2) -&gt; equal | 
                                                      greater | 
                                                      less)
             | state : {StateTarget, 
                        Function = fun(StateTarget, delete, Key) 
                                 -&gt; true,
                        Function = fun(StateTarget, insert, Subtrees) 
                                 -&gt; Key,
                        Function = fun(StateTarget, lookup, Key) 
                                 -&gt; Subtrees}
</code></pre>

<p>Sets the parameter Name to value Value in the empty b-tree B-Tree1 and 
returns the new b-tree B-Tree2.  This function can only be used in 
conjunction with an empty b-tree.</p>
      <h3 id="size_key_values-b-tree---integer--0">
        
        
          size_key_values (B-Tree) -&gt; integer() &gt;= 0 <a href="#size_key_values-b-tree---integer--0">#</a>
        
        
      </h3>
    

<p>Types:</p>

<pre><code class="language-erlang">B-Tree = b_tree()
</code></pre>

<p>Returns the number of key value pairs in b-tree B-Tree as an integer.<br />
Returns 0 (zero) if b-tree B-Tree is empty.</p>
      <h3 id="size_nodes-b-tree---integer--0-integer--0">
        
        
          size_nodes (B-Tree) -&gt; {integer() &gt;= 0, integer() &gt;= 0} <a href="#size_nodes-b-tree---integer--0-integer--0">#</a>
        
        
      </h3>
    

<p>Types:</p>

<pre><code class="language-erlang">B-Tree = b_tree()
</code></pre>

<p>Returns the number of total nodes and the number of leaf nodes in b-tree 
B-Tree as a tuple of two integers.  Returns {0, 0} (zero) if b-tree B-Tree 
is empty.</p>
      <h3 id="smallest-b-tree---key-value">
        
        
          smallest (B-Tree) -&gt; {Key, Value} <a href="#smallest-b-tree---key-value">#</a>
        
        
      </h3>
    

<p>Types:</p>

<pre><code class="language-erlang">B-Tree = b_tree()
Key = any()
Value = any()
</code></pre>

<p>Returns tuple {Key, Value}, where Key is the smallest key in b-tree 
B-Tree, and Value is the value associated with this key.  Assumes that 
b-tree B-Tree is not empty.</p>
      <h3 id="sort_ascending-key1-key2---equal--greater--less">
        
        
          sort_ascending (Key1, Key2) -&gt; ‘equal’ | ‘greater’ | ‘less’ <a href="#sort_ascending-key1-key2---equal--greater--less">#</a>
        
        
      </h3>
    

<p>Types:</p>

<pre><code class="language-erlang">Key1 = Key2  = any()
equal = greater = less = atom()
</code></pre>

<p>Returns the atom ‘<strong>greater</strong>’ if Key1 &gt; Key2, the atom ‘<strong>less</strong>’ 
if Key1 &lt; Key2 and otherwise the atom ‘<strong>equal</strong>’.</p>
      <h3 id="sort_descending-key1-key2---equal--greater--less">
        
        
          sort_descending (Key1, Key2) -&gt; ‘equal’ | ‘greater’ | ‘less’ <a href="#sort_descending-key1-key2---equal--greater--less">#</a>
        
        
      </h3>
    

<p>Types:</p>

<pre><code class="language-erlang">Key1 = Key2  = any()
equal = greater = less = atom()
</code></pre>

<p>Returns the atom ‘<strong>less</strong>’ if Key1 &gt; Key2, the atom ‘<strong>greater</strong>’ 
if Key1 &lt; Key2 and otherwise the atom ‘<strong>equal</strong>’.</p>
      <h3 id="takekey-b-tree1---b-tree2">
        
        
          take(Key, B-Tree1) -&gt; B-Tree2 <a href="#takekey-b-tree1---b-tree2">#</a>
        
        
      </h3>
    

<p>Types:</p>

<pre><code class="language-erlang">Key = any()
B-Tree1 = B-Tree2 = b_tree()
</code></pre>

<p>Removes the node with key Key from b-tree B-Tree1 and returns the new 
b-tree B-Tree2.  Assumes that key Key is present in b-tree B-Tree1, 
crashes otherwise.</p>
      <h3 id="delete_any-key-b-tree1---b-tree2-1">
        
        
          delete_any (Key, B-Tree1) -&gt; B-Tree2 <a href="#delete_any-key-b-tree1---b-tree2-1">#</a>
        
        
      </h3>
    

<p>Types:</p>

<pre><code class="language-erlang">Key = any()
B-Tree1 = B-Tree2 = b_tree()
</code></pre>

<p>Removes the node with key Key from b-tree B-Tree1 if key Key is present 
in b-tree B-Tree1, otherwise does nothing. Returns the new b-tree B-Tree2.</p>
      <h3 id="take_largest-b-tree1---key-value-b-tree2">
        
        
          take_largest (B-Tree1) -&gt; {Key, Value, B-Tree2} <a href="#take_largest-b-tree1---key-value-b-tree2">#</a>
        
        
      </h3>
    

<p>Types:</p>

<pre><code class="language-erlang">B-Tree1 = B-Tree2 = b_tree()
Key = any()
Value = any()
</code></pre>

<p>Returns tuple {Key, Value, B-Tree2}, where Key is the largest key in 
b-tree B-Tree1, Value is the value associated with this key, and b-tree 
B-Tree2 is this b-tree with the corresponding key value pair deleted.<br />
Assumes that b-tree B-Tree1 is not empty.</p>
      <h3 id="take_smallest-b-tree1---key-value-b-tree2">
        
        
          take_smallest (B-Tree1) -&gt; {Key, Value, B-Tree2} <a href="#take_smallest-b-tree1---key-value-b-tree2">#</a>
        
        
      </h3>
    

<p>Types:</p>

<pre><code class="language-erlang">B-Tree1 = B-Tree2 = b_tree()
Key = any()
Value = any()
</code></pre>

<p>Returns tuple {Key, Value, B-Tree2}, where Key is the smallest key in 
b-tree B-Tree1, Value is the value associated with this key, and b-tree 
B-Tree2 is this b-tree with the corresponding key value pair deleted.<br />
Assumes that b-tree B-Tree1 is not empty.</p>
      <h3 id="to_list-b-tree---key-value">
        
        
          to_list (B-Tree) -&gt; [{Key, Value}] <a href="#to_list-b-tree---key-value">#</a>
        
        
      </h3>
    

<p>Types:</p>

<pre><code class="language-erlang">B-Tree = b_tree()
Key = any()
Value = any()
</code></pre>

<p>Converts b-tree B-Tree into an ordered list of key value tuples.</p>
      <h3 id="update-key-value-b-tree1---b-tree2">
        
        
          update (Key, Value, B-Tree1) -&gt; B-Tree2 <a href="#update-key-value-b-tree1---b-tree2">#</a>
        
        
      </h3>
    

<p>Types:</p>

<pre><code class="language-erlang">Key = any()
Value = any()
B-Tree1 = B-Tree2 = b_tree()
</code></pre>

<p>Updates key Key to value Value in b-tree B-Tree1 and returns the new 
b-tree B-Tree2.  Assumes that key Key is present in b-tree B-Tree1.</p>
      <h3 id="values-b-tree---value">
        
        
          values (B-Tree) -&gt; [Value] <a href="#values-b-tree---value">#</a>
        
        
      </h3>
    

<p>Types:</p>

<pre><code class="language-erlang">B-Tree = b_tree()
Value = any()
</code></pre>

<p>Returns the values in b-tree B-Tree as an ordered list, sorted by their 
corresponding keys.  Duplicates are not removed.</p>
      <h2 id="pluggable-persistence-functionality">
        
        
          Pluggable Persistence Functionality <a href="#pluggable-persistence-functionality">#</a>
        
        
      </h2>
    
      <h3 id="format">
        
        
          Format: <a href="#format">#</a>
        
        
      </h3>
    

<pre><code class="language-erlang">{StateTarget, DeleteFunction, InsertFunction, LookupFunction}

StateTarget = any()

DeleteFunction(StateTarget, delete, Key) -&gt; true

InsertFunction(StateTarget, insert, Subtrees) -&gt; Key

LookupFunction(StateTarget, lookup, Key) -&gt; Subtrees
</code></pre>

<p>Examples for state targets are a Dets table or a Mnesia table.  The delete 
function takes a state target, the atom <code>delete</code> and a key as arguments 
and returns the atom <code>true</code> if successful.  The insert function takes a 
state target, the atom <code>insert</code> and a subtrees data structure as arguments 
and returns a key if successful.  The lookup function takes a state target, 
the atom <code>lookup</code> and a key as arguments and returns a subtrees data 
structure if successful.</p>
      <h3 id="example-functions">
        
        
          Example functions: <a href="#example-functions">#</a>
        
        
      </h3>
    

<p>The following examples are based on Mnesia.</p>

<pre><code class="language-erlang">persistence_by_mnesia(_, delete, SubtreesKey) 
                     when is_list(SubtreesKey) -&gt;
    true;
persistence_by_mnesia(StateTarget, delete, SubtreesKey) -&gt;
    F = fun() -&gt;
        ok = mnesia:delete({StateTarget, SubtreesKey}),
        true
    end,
    mnesia:activity(transaction, F);
    
persistence_by_mnesia(_, insert, []) -&gt;
    [];
persistence_by_mnesia(StateTarget, insert, 
                      [{_, _, [{Key, _} | _], _} | _] = Subtrees) -&gt;
    SubtreesKey = list_to_binary(Key),
    F = fun() -&gt;
        ok = mnesia:write(StateTarget, 
                          #subtrees{subtreesKey = SubtreesKey, 
                          subtrees = Subtrees}, write),
        SubtreesKey
    end,
    mnesia:activity(transaction, F);
    
persistence_by_mnesia(_, lookup, SubtreesKey) 
                     when is_list(SubtreesKey) -&gt;
    SubtreesKey;
persistence_by_mnesia(StateTarget, lookup, SubtreesKey) -&gt;
    F = fun() -&gt;
        [{subtrees, SubtreesKey, Subtrees}] = mnesia:read(StateTarget, 
                                                          SubtreesKey),
        Subtrees
    end,
mnesia:activity(transaction, F).
</code></pre>
      <h3 id="example-usage">
        
        
          Example usage: <a href="#example-usage">#</a>
        
        
      </h3>
    

<p>Creating the Mnesia table:</p>

<pre><code class="language-erlang">-record(subtrees, {subtreesKey, subtrees}).
    
{atomic, ok} = mnesia:create_table(StateTargetName, [{record_name, 
                                                      subtrees}]),
</code></pre>

<p>Creating the b-tree:</p>

<pre><code class="language-erlang">BTree1 = b_trees:empty(500),
BTree2 = b_trees:set_parameter(BTree1, state, 
                               {StateTargetName, 
                                fun persistence_by_mnesia/3, 
                                fun persistence_by_mnesia/3, 
                                fun persistence_by_mnesia/3}),
</code></pre>
      <h2 id="pluggable-sort-functionality">
        
        
          Pluggable Sort Functionality <a href="#pluggable-sort-functionality">#</a>
        
        
      </h2>
    
      <h3 id="format-1">
        
        
          Format: <a href="#format-1">#</a>
        
        
      </h3>
    

<pre><code class="language-erlang">FunctionName(Key1, Key2) -&gt; equal | greater | less

Key1 = Key2 = any()
</code></pre>

<p>The sort function takes two keys as arguments and returns the atom <code>less</code> 
if Key1 &lt; Key2, the atom <code>greater</code> if Key1 &gt; Key2 and otherwise the 
atom <code>equal</code>.</p>
      <h3 id="example-function">
        
        
          Example function: <a href="#example-function">#</a>
        
        
      </h3>
    

<pre><code class="language-erlang">-spec sort_descending(key(), key()) -&gt; sort_result().

sort_descending(Key_1, Key_2) -&gt;
if
    Key_1 &lt; Key_2 -&gt; greater;
    Key_1 &gt; Key_2 -&gt; less;
    true -&gt; equal
end.
</code></pre>
      <h3 id="example-usage-1">
        
        
          Example usage: <a href="#example-usage-1">#</a>
        
        
      </h3>
    

<pre><code class="language-erlang">BTree1 = b_trees:empty(500),
BTree2 = b_trees:set_parameter(BTree1, sort, fun sort_descending/2),
</code></pre>
      <h1 id="motivation">
        
        
          Motivation <a href="#motivation">#</a>
        
        
      </h1>
    

<p>B-trees are self-balancing tree data structures that keep data sorted 
and allow searches, sequential access, insertions, and deletions in 
logarithmic time.  B-trees are a generalization of a binary search 
trees in that a node can have more than two children.  Unlike self-balancing 
binary search trees, the b-tree is optimized for systems that read and 
write large blocks of data.  B-trees are a good example of a data structure 
for external memory.</p>
      <h1 id="rationale">
        
        
          Rationale <a href="#rationale">#</a>
        
        
      </h1>
    

<p>The functional design of the module b_trees is based on the module gb_trees:</p>

<pre><code class="language-erlang"> b_trees          | gb_trees
------------------|---------
 n/a              | balance/1
 copy/2           | n/a
 delete/2         | delete/2
 delete_any/2     | delete_any/2
 empty/1          | empty/0
 enter/3          | enter/3
 from_dict/2      | from_orddict/1
 get/2            | get/2
 height/1         | n/a
 insert/3         | insert/3
 is_defined/2     | is_defined/2
 is_empty/1       | is_empty/1
 iterator/1       | iterator/1
 iterator_from/2  | iterator_from/2
 keys/1           | keys/1
 largest/1        | largest/1
 lookup/2         | lookup/2
 map/2            | map/2
 next/1           | next/1
 set_parameter/3  | n/a
 size_key_values/1| size/1
 size_nodes/1     | n/a
 smallest/1       | smallest/1
 sort_ascending/2 | n/a
 sort_descending/2| n/a
 take/2           | take/2
 take_any/2       | take_any/2
 take_largest/1   | take_largest/1
 take_smallest/1  | take_smallest/1
 to_list/1        | to_list/1
 update/3         | update/3
 values/1         | values/1
</code></pre>

<p>The functions <code>delete/2</code> and <code>insert/3</code> are implementations of the algorithms 
of Cormen, Thomas; Leiserson, Charles; Rivest, Ronald; Stein, Clifford (2009), 
Introduction to Algorithms (Third ed.), MIT Press and McGraw-Hill, pp. 484-504, 
ISBN 0-262-03384-4. Chapter 18: B-Trees.</p>
      <h1 id="backwards-compatibility">
        
        
          Backwards Compatibility <a href="#backwards-compatibility">#</a>
        
        
      </h1>
    

<p>No issues - except module name collisions.</p>
      <h1 id="reference-implementation">
        
        
          Reference Implementation <a href="#reference-implementation">#</a>
        
        
      </h1>
    

<p>The reference implementation can be fetched from Github:</p>

<pre><code class="language-erlang">https://github.com/walter-weinmann/b_trees
</code></pre>

            </div>
        </div>
    </div>
</div>
<script src="/assets/js/prismjs/prism.js"></script>
<script src="/assets/js/prismjs/components/prism-erlang.js"></script>
    <footer class="container-fluid footer text-center border-top border-bottom">
        <div>
            <a href="/downloads.html" title="DOWNLOAD"><img src="/assets/img/download.png" alt="Download Erlang/OTP"></a>
        </div>
        <div>
            <a href="http://www.github.com/erlang/otp"><img
                    src="/assets/img/GitHub-Mark-32px.png" alt="Erlang/OTP on Github"></a>
        </div>
        
        <div>
            <a href="http://www.twitter.com/erlang_org"><img src="/assets/img/twitter.png"
                    width="32" alt="Erlang/OTP twitter"></a>
        </div>
    </footer>
    <script src="/assets/js/bootstrap/dist/js/bootstrap.bundle.min.js"></script>
</body>

</html>