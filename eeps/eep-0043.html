<!DOCTYPE html>
<html lang="en">



<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

    <!-- Allow pinning of website on windows -->
    <meta name="application-name" content="Erlang.org">
    <meta name="msapplication-tooltip" content="The official home of the Erlang Programming Language">
    <meta name="msapplication-starturl" content="/" >

    <!-- Make the site look nicer on facebook -->
    <meta property="og:type" content="website">
    <meta property="og:site_name" content="Erlang.org">
    <meta property="og:title" content="Welcome to Erlang.org">
    <meta property="og:description" content="The official home of the Erlang Programming Language">
    <meta property="og:image" content="https://beta.erlang.org/assets/img/erlang-228x200.png">
    <meta property="og:image:secure_url" content="https://beta.erlang.org/assets/img/erlang-228x200.png">
    <meta property="og:url" content="https://beta.erlang.org/">

    <!-- Twitter metadata -->
    <meta name="twitter:card" content="summary" />
    <meta property="twitter:title" content="Index" />
    <meta name="twitter:site" content="@erlang_org" />

    <!-- Rich data for google search -->
    <script type="application/ld+json">
{"@type":"WebSite","url":"https://erlang.org/","headline":"Eep 0043 - Erlang/OTP","name":"Erlang.org","sameAs":["https://twitter.com/erlang_org","https://github.com/erlang/otp"],"@context":"https://schema.org"}</script>

    <title>Eep 0043 - Erlang/OTP</title>

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- tells iOS browsers to not show telephone numbers as links -->
    <meta name="format-detection" content="telephone=no">

    <meta name="application-name" content="Erlang.org">
    <meta name="description" content="The official home of the Erlang Programming Language">
    <meta name="keywords" content="Erlang programming language functional parallel distributed documentation download community">
    <!-- https://www.rssboard.org/rss-autodiscovery -->
    <link rel="alternate" type="application/atom+xml" title="News Atom Feed" href="https://beta.erlang.org/news.xml" />
    <link rel="alternate" type="application/atom+xml" title="Blog Atom Feed" href="https://beta.erlang.org/blog.xml" />
    
    <link rel="stylesheet" href="/assets/css/main.css">
</head>

<body>
    <header class="navbar navbar-expand-lg navbar-light bg-body">
        <nav class="container">
            <button class="navbar-toggler" type="button" data-toggle="collapse" data-bs-toggle="collapse"
                data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false"
                aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <a class="navbar-brand" href="/"><img
                    src="/assets/img/erlang.png" class="img-fluid" width="60" alt="Erlang.org main page"/></a>
            <div class="collapse navbar-collapse fw-bold" id="navbarSupportedContent">
                <ul class="navbar-nav text-uppercase me-auto mb-2 mb-lg-0">
                    <li class="nav-item"><a class="nav-link" href="/downloads">Download</a></li>
                    <li class="nav-item"><a class="nav-link" href="/docs">Documentation</a></li>
                    <li class="nav-item"><a class="nav-link" href="/community">Community</a></li>
                    <li class="nav-item"><a class="nav-link" href="/news">News</a></li>
                    <li class="nav-item"><a class="nav-link" href="/blog">Blog</a></li>
                    <li class="nav-item"><a class="nav-link" href="/eep">EEP</a></li>
                    <li class="nav-item"><a class="nav-link" href="/about">About</a></li>
                </ul>
                <form class="d-flex" role="search" method="get" action="https://duckduckgo.com/">
                    <input type="hidden" name="sites" value="erlang.org">
                    <input class="form-control me-2" id="searchfield" name="q" type="search" placeholder="Search erlang.org"
                        aria-label="Search">
                    <button class="btn btn-outline-primary" type="submit">Search</button>
                </form>
            </div>
        </nav>
    </header>
    <div class="container border-top pt-4">
    <div class="row-lg">
        <div class="col-lg-10 offset-lg-1">
            <div class="card">
                <div class="card-body">
                    <dl class="mb-0 dl-single">
                        <dt>Author:</dt>
                        <dd>
                            Björn-Egil Dahlberg &lt;egil(at)Erlang.org&gt;
                            
                            
                        </dd>
                        
                        <dt>Status:</dt>
                        <dd>Draft </dd>
                        <dt>Type:</dt>
                        <dd>Standards Track</dd>
                        
                        
                        <dt>Created:</dt>
                        <dd>04-Apr-2013</dd>
                        
                        <dt>Erlang-Version:</dt>
                        <dd>R17A</dd>
                        
                        
                        
                        
                    </dl>
                </div>
            </div>
            <div class="border-top mt-4">
                
                <h2 id="eep-43-maps">
        
        
          EEP 43: Maps <a href="#eep-43-maps">#</a>
        
        
      </h2>
    
      <h1 id="abstract">
        
        
          Abstract <a href="#abstract">#</a>
        
        
      </h1>
    

<p>The journey of Maps and this EEP has been long and by no means a
straight-forward and continuous one. I had a crystal clear picture of what I
wanted Maps to be when we first started discussing it within OTP about
two-three years ago. This EEP resembles that vision but it has had a lot of
contributions of other ideas from both within and outside of OTP.</p>

<p>The idea was a data-type, a syntax aware mapping of key-value associations
with pattern matching. A syntax similar to records but without the hassle of
compile-time dependency and with arbitrary terms as keys. Order was not
important and it could be implemented with a Hash-Array-Mapped-Trie with good
performance and memory trade-offs. This was a different approach than to replace
records. It was meant to replace records where suitable and in other regards
not be a replacement but its own <em>thing</em>.</p>

<blockquote class='blockquote'>
  <p>From the community there has been many wishes of a Map like data-type and a
few suggestions.  The one suggestion that stands out is of course the Frames
proposal from Richard O’Keefe. It is the most complete proposal I’ve seen and
is very well thought out. Its goal is to be a record replacement and the
proposal satisfies this goal very well.</p>
</blockquote>

<ul>
  <li>If Frames are that good, why a separate EEP?</li>
  <li>It boils down to goals and constraints.</li>
</ul>

<p>A record replacement is just that, a replacement.
It’s like asking the question, “What do we have?” instead of “What can we get?”
The instant rebuttal would be “What do we need?” I say Maps.</p>

<p>Frames has certainly inspired and influenced Maps. In many regards Maps also
encompasses Frames but Maps tries to do more. In the end I believe they are
two different things and have different goals.</p>

<p>This EEP suggests a new built in data-type for Erlang, the map, 
<code>#{ Key =&gt; Value }</code>.</p>

<p>The new data-type shall have semantics, syntax and operations that:</p>

<ul>
  <li>provides an association set from key terms to value terms which can be
constructed, accessed and updated using language syntax</li>
  <li>can be uniquely distinguished from every other data-type in the language</li>
  <li>has no compile-time dependency for constructing, accessing or updating
contents of maps nor for passing maps between modules, processes or over
Erlang distribution</li>
  <li>can be used in matching expressions in the language</li>
  <li>has a one-to-one association between printing and parsing the data-type</li>
  <li>has a well defined order between terms of the type and other Erlang types</li>
  <li>has at most O(log N) time complexity in insert and lookup operations, where 
N is the number of key-value associations.</li>
</ul>

<p>Similar data-types exists in other languages, i.e.  <a href="http://perldoc.perl.org/perldata.html" title="perldata - perldoc.perl.org">perl hashes</a>,
<a href="http://ruby-doc.org/core-1.9.3/Hash.html" title="Class: Hash (Ruby 1.9.3)">ruby hashes</a>, <a href="http://docs.python.org/tutorial/datastructures.html#dictionaries" title="5. Data Structures - Python v2.7.3 documentation">python dictionaries</a>, or
<a href="http://docs.scala-lang.org/overviews/collections/maps.html" title="Collections - Maps - Scala Documentation">scala maps</a>.</p>
      <h1 id="specification">
        
        
          Specification <a href="#specification">#</a>
        
        
      </h1>
    

<p>A map <code>M</code> consists of a number of <em>associations</em> and keeps an association
from key terms <code>K1..Kn</code> to value terms <code>V1..Vn</code> where no two keys <em>match</em>.
Any term, compound or otherwise, is a viable key or value. Terms of type Map
are recognized by guard tests <code>erlang:is_map/1</code>. There are no operators
acting on maps. Within maps there are two infix operators. An association
operator, <code>=&gt;</code>, pairs a key to a value and is used in creation and updates.
A set-value operator, <code>:=</code>, is used to update a value on an already
existing and matching key. The set-value operator is also used in matching
to get the associated value from a key.</p>
      <h2 id="terminology">
        
        
          Terminology <a href="#terminology">#</a>
        
        
      </h2>
    

<p>The <em>size</em> of a map is the number of associations in its set.</p>

<p>An <em>association</em> is a key-value pair of key <em>K</em> to value <em>V</em> in a Map.</p>

<p>Two keys, <code>K1</code> and <code>K2</code> are <em>matching</em> if, <code>true = K1 =:= K2</code>.</p>
      <h2 id="syntax">
        
        
          Syntax <a href="#syntax">#</a>
        
        
      </h2>
    

<p>Defined syntax for declaring, updating and matching maps.</p>
      <h3 id="construction-syntax">
        
        
          Construction syntax <a href="#construction-syntax">#</a>
        
        
      </h3>
    

<p>Constructing a new map is done by letting an expression <code>K</code> be associated to
another expression <code>V</code>:</p>

<pre><code class="language-erlang">#{ K =&gt; V }
</code></pre>

<p>New maps may include multiple associations at construction by listing every
association:</p>

<pre><code class="language-erlang">#{ K1 =&gt; V1, .. Kn =&gt; Vn }
</code></pre>

<p>An empty map is constructed by not associating any terms with each other:</p>

<pre><code class="language-erlang">#{}        
</code></pre>

<p>All keys and values in the map are terms. Any expression is first evaluated and
then the resulting terms are used as <em>key</em> and <em>value</em> respectively.</p>

<p>Keys and values are separated by the <code>=&gt;</code> arrow and associations are
separated by <code>,</code>.</p>

<p>Examples:</p>

<pre><code class="language-erlang">M0 = #{},                   % empty map
M1 = #{ a =&gt; &lt;&lt;"hello"&gt;&gt; }, % single association with literals
M2 = #{ 1 =&gt; 2, b =&gt; b },   % multiple associations with literals
M3 = #{ A =&gt; B },           % single association with variables
M4 = #{ {A, B} =&gt; f() }.    % compound key associated to an evaluated expression
</code></pre>

<p>where, <code>A</code> and <code>B</code> are any expressions and <code>M0</code> through <code>M4</code> are the resulting
map terms.</p>

<p>If two matching keys are declared, the latter key will take precedent.</p>

<p>Example:</p>

<pre><code class="language-erlang">1&gt; #{ 1 =&gt; a, 1 =&gt; b }.
#{ 1 =&gt; b }
2&gt; #{ 1.0 =&gt; a, 1 =&gt; b }.
#{ 1 =&gt; b, 1.0 =&gt; a }
</code></pre>

<p>The order in which the expressions constructing the keys and their
associated values are evaluated is not defined. The syntactic order of
the key-value pairs in the construction is of no relevance, except in
the above mentioned case of two matching keys.</p>

<p>A simple BNF grammar for the construction follows:</p>

<pre><code class="language-erlang"> &lt;map-construct&gt;  ::= '#{' &lt;key-value-exprs&gt; '}'
&lt;key-value-exprs&gt; ::= /* empty */
                    | &lt;key-value-list&gt;
 &lt;key-value-list&gt; ::= &lt;key-value-assoc&gt; 
                    | &lt;key-value-assoc&gt; ',' &lt;key-value-list&gt;
&lt;key-value-assoc&gt; ::= &lt;expr&gt; '=&gt;' &lt;expr&gt;
           &lt;expr&gt; ::= &lt;Erlang-expression&gt;
</code></pre>
      <h3 id="update-syntax">
        
        
          Update syntax <a href="#update-syntax">#</a>
        
        
      </h3>
    

<p>Updating a map has similar syntax as constructing it.</p>

<p>An expression defining the map to be updated is put in front of the expression
defining the keys to be updated and their respective values.</p>

<pre><code class="language-erlang">M#{ K =&gt; V }
</code></pre>

<p>where <code>M</code> is an term of type map and <code>K</code> and <code>V</code> are any expression.</p>

<p>If key <code>K</code> does not <em>match</em> any existing key in the map, a new association
will be created from key <code>K</code> to value <code>V</code>.  If key <code>K</code> <em>matches</em> an existing
key in map <code>M</code> its associated value will be replaced by the new value <code>V</code>. In both
cases the evaluated map expression will return a new map.</p>

<p>If <code>M</code> is not of type map an exception of type <code>badmap</code> is thrown.</p>

<p>To only update an existing value, the following syntax is used,</p>

<pre><code class="language-erlang">M#{ K := V }
</code></pre>

<p>where <code>M</code> is an term of type map, <code>V</code> is an expression and <code>K</code> is an expression
which evaluates to an existing key in <code>M</code>.</p>

<p>If key <code>K</code> does not <em>match</em> any existing keys in map <code>M</code> an exception of type
<code>badarg</code> will be triggered at runtime. If a <em>matching</em> key <code>K</code> is present in
map <code>M</code> its associated value will be replaced by the new value <code>V</code> and the
evaluated map expression returns a new map.</p>

<p>If <code>M</code> is not of type map an exception of type <code>badmap</code> is thrown.</p>

<p>Examples:</p>

<pre><code class="language-erlang">M0 = #{},
M1 = M0#{ a =&gt; 0 },
M2 = M1#{ a =&gt; 1, b =&gt; 2 },
M3 = M2#{ "function" =&gt; fun() -&gt; f() end },
M4 = M3#{ a := 2, b := 3 }.  % 'a' and 'b' was added in `M1` and `M2`.
</code></pre>

<p>where <code>M0</code> is any map. It follows that <code>M1 .. M4</code> are maps as well.</p>

<p>More Examples:</p>

<pre><code class="language-erlang">1&gt; M = #{ 1 =&gt; a }.
#{ 1 =&gt; a }

2&gt; M#{ 1.0 =&gt; b }.
#{ 1 =&gt; a, 1.0 =&gt; b }.

3&gt; M#{ 1 := b }.
#{ 1 =&gt; b }

4&gt; M#{ 1.0 := b }.
** exception error: bad argument
</code></pre>

<p>As in construction, the order in which the key and value expressions
are evaluated are not defined. The
syntactic order of the key-value pairs in the update is of no
relevance, except in the case where two keys match, in which
case the latter value is used.</p>

<p>A simple BNF grammar for map updates follows:</p>

<pre><code class="language-erlang"> &lt;map-construct&gt;  ::= &lt;map-expr&gt; '#{' &lt;key-value-exprs&gt; '}'
&lt;key-value-exprs&gt; ::= /* empty */
                    | &lt;key-value-list&gt;
 &lt;key-value-list&gt; ::= &lt;key-value&gt; 
                    | &lt;key-value&gt; ',' &lt;key-value-list&gt;
      &lt;key-value&gt; ::= &lt;key-value-assoc&gt;
                    | &lt;key-value-exact&gt;
&lt;key-value-assoc&gt; ::= &lt;expr&gt; '=&gt;' &lt;expr&gt;
&lt;key-value-exact&gt; ::= &lt;expr&gt; ':=' &lt;expr&gt;
       &lt;map-expr&gt; ::= &lt;Erlang expression evaluating to a term of type map&gt;
           &lt;expr&gt; ::= &lt;Erlang expression&gt;
</code></pre>
      <h3 id="accessing-a-single-value">
        
        
          Accessing a single value <a href="#accessing-a-single-value">#</a>
        
        
      </h3>
    

<p>For accessing single values in maps, let us use an de-association:</p>

<pre><code class="language-erlang">V = M#{ K }.
</code></pre>

<p>Where <code>M</code> is a Map and <code>K</code> is any term.</p>

<p>If key <code>K</code> <em>matches</em> to an existing key in map <code>M</code> the associated value
will be bound to <code>V</code>. If key <code>K</code> does not <em>match</em> to any existing key in
map <code>M</code> an exception <code>badarg</code> will occur in runtime.</p>

<p>Examples:</p>

<pre><code class="language-erlang">M1 = #{ a =&gt; 1, c =&gt; 3 },
3 = M1#{ c }.

M2 = #{ 1.0 =&gt; a },
a = M2#{ 1 }.
</code></pre>
      <h3 id="matching-syntax">
        
        
          Matching syntax <a href="#matching-syntax">#</a>
        
        
      </h3>
    

<p>Matching of key-value associations from maps, exemplified with the
matching operator, is done in the following way:</p>

<pre><code class="language-erlang">#{ K := V } = M
</code></pre>

<p>where <code>M</code> is any map. The key <code>K</code> has to be an expression with bound variables
or a literals, and <code>V</code> can be any pattern with either bound or unbound variables.
If variables in <code>V</code> are unbound, it will be bound to the value associated
with the key <code>K</code>, which has to exist in the map <code>M</code>. If variables in <code>V</code> are
bound, it has to match the value associated with <code>K</code> in <code>M</code>.</p>

<p>Example:</p>

<pre><code class="language-erlang">M = #{ a =&gt; {1,2}},
#{ a := {1,B}} = M.
</code></pre>

<p>This will bind variable <code>B</code> to integer <code>2</code>.</p>

<p>Similarly, multiple values from the map may be matched:</p>

<pre><code class="language-erlang">#{ K1 := V1, .., Kn := Vn } = M
</code></pre>

<p>where keys <code>K1 .. Kn</code> are any expressions with literals or bound variables. If all
keys exists in map <code>M</code> all variables in <code>V1 .. Vn</code> will be matched to the
associated values of there respective keys.</p>

<p>If the matching conditions are not met, the match will fail, either with</p>

<ol>
  <li>a <code>badmatch</code> exception, if used in the context of the matching operator
as in the example,</li>
  <li>or resulting in the next clause being tested in function heads and
case expressions.</li>
</ol>

<p>Matching in maps only allows for <code>:=</code> as delimiters of associations.</p>

<p>The order in which keys are declared in matching has no relevance.</p>

<p>Duplicate keys are allowed in matching and will match each pattern associated
to the keys.</p>

<pre><code class="language-erlang">#{ K := V1, K := V2 } = M
</code></pre>

<p>Matching an expression against an empty map literal will match its type but
no variables will be bound:</p>

<pre><code class="language-erlang">#{} = Expr
</code></pre>

<p>This expression will match if the expression <code>Expr</code> is of type map, otherwise
it will fail with an exception <code>badmatch</code>.</p>

<p>The grammar for the matching syntax is similar to that of construction.</p>
      <h4 id="matching-syntax-example-with-literals-in-function-heads">
        
        
          Matching syntax: Example with literals in function heads <a href="#matching-syntax-example-with-literals-in-function-heads">#</a>
        
        
      </h4>
    

<p>Matching of literals as keys are allowed in function heads.</p>

<pre><code class="language-erlang">%% only start if not_started
handle_call(start, From, #{ state := not_started } = S) -&gt;
...
    {reply, ok, S#{ state := start }};

%% only change if started
handle_call(change, From, #{ state := start } = S) -&gt;
...
    {reply, ok, S#{ state := changed }};
</code></pre>
      <h4 id="matching-syntax-frequency-example">
        
        
          Matching syntax: Frequency example <a href="#matching-syntax-frequency-example">#</a>
        
        
      </h4>
    

<p>More matching syntax, calculating frequency of terms in a list.</p>

<pre><code class="language-erlang">freq(Is)                    -&gt; freq(Is, #{}).
freq([I|Is], #{I := C} = M) -&gt; freq(Is, M#{ I := C + 1});
freq([I|Is], M)             -&gt; freq(Is, M#{ I =&gt; 1 });
freq([], M)                 -&gt; maps:to_list(M).
</code></pre>

<p>Equivalent code with <code>gb_trees</code> for comparison:</p>

<pre><code class="language-erlang">freq(Is)        -&gt; freq(Is, gb_trees:empty()).
freq([I|Is], T) -&gt;
    case gb_trees:lookup(I, T) of 
        none       -&gt; freq(Is, gb_trees:enter(I, 1), T);
        {value, V} -&gt; freq(Is, gb_trees:enter(I, V + 1, T))
    end;
freq([], T) -&gt; gb_trees:to_list(T).
</code></pre>
      <h4 id="matching-syntax-file-information-example">
        
        
          Matching syntax: File information example <a href="#matching-syntax-file-information-example">#</a>
        
        
      </h4>
    

<p>Old API’s could be refined to use map syntax:</p>

<pre><code class="language-erlang">1&gt; {ok, #{ type := Type, mtime := Mtime }} = file:read_file_info(File).
2&gt; io:format("type: ~p, mtime: ~p~n", [Type, Mtime]).
type: regular, mtime: {{2012,7,18},{19,59,18}}
ok
3&gt;
</code></pre>
      <h3 id="map-comprehension-syntax">
        
        
          Map comprehension syntax <a href="#map-comprehension-syntax">#</a>
        
        
      </h3>
    

<p>Map comprehension declaration:</p>

<pre><code class="language-erlang">M1 = #{ E0 =&gt; E1 || K := V &lt;- M0  }
</code></pre>

<p>where <code>M0</code> is any Map, <code>E0</code> and <code>E1</code> are any erlang expression, <code>K</code> and <code>V</code>
constitutes the pattern to be matched by each association in <code>M0</code>.</p>

<p>For each sequence in the generator an association is created from the evaluated
expression <code>E0</code> to the evaluated expression <code>E1</code>.</p>

<p>If <code>M0</code> is not a Map, then a runtime exception of type <code>{bad_generator, M0}</code>
will be generated.</p>

<p>A simple BNF grammar for map comprehension follows:</p>

<pre><code class="language-erlang">      &lt;comprehension&gt; ::= '#{' &lt;key-value-assoc&gt; '||' &lt;comprehension-exprs&gt; '}'
&lt;comprehension-exprs&gt; ::= &lt;comprehension-expr&gt;
                        | &lt;comprehension-exprs&gt; ',' &lt;comprehension-expr&gt;
 &lt;comprehension-expr&gt; ::= &lt;generator&gt;
                        | &lt;filter&gt;
          &lt;generator&gt; ::= &lt;key-value-exact&gt; '&lt;-' &lt;expr&gt;
             &lt;filter&gt; ::= &lt;expr&gt;
    &lt;key-value-assoc&gt; ::= &lt;expr&gt; '=&gt;' &lt;expr&gt;
    &lt;key-value-exact&gt; ::= &lt;expr&gt; ':=' &lt;expr&gt;
               &lt;expr&gt; ::= &lt;Erlang expression&gt;
</code></pre>

<p>Each association from all generators, which satisfies the filters, has an
environment that consist of the initial environment and the environment
for the association.</p>

<p>Examples:</p>

<pre><code class="language-erlang">M0 = #{ K =&gt; V*2  || K := V &lt;- map() },
M1 = #{ I =&gt; f(I) || I &lt;- list() },
M2 = #{ K =&gt; V    || &lt;&lt;L:8,K:L/binary,V/float&gt;&gt; &lt;= binary() }.
</code></pre>

<p>Map generators may also be used in binary and list comprehensions.</p>

<p>Examples:</p>

<pre><code class="language-erlang">B1 = &lt;&lt; &lt;&lt;V:8&gt;&gt; || _ := V &lt;- map() &gt;&gt;,
L1 = [ {K,V} || K := V &lt;- map() ].
</code></pre>
      <h3 id="dialyzer-and-type-specification">
        
        
          Dialyzer and Type specification <a href="#dialyzer-and-type-specification">#</a>
        
        
      </h3>
    

<p>Keys known before hand can be specified directly and uniquely for a map.</p>

<pre><code class="language-erlang">-spec func(Opt, M) -&gt; #{ 'status' =&gt; S, 'c' =&gt; integer() } when
      Opt :: 'inc' | 'dec',
        M :: #{ 'status' =&gt; S, 'c' =&gt; integer() },
        S :: 'update' | 'keep'.

func(inc, #{ status := update, c := C} = M) -&gt; M#{ c := C + 1};
func(dec, #{ status := update, c := C} = M) -&gt; M#{ c := C - 1};
func(_,   #{ status := keep } = M)          -&gt; M.
</code></pre>

<p>It could also be specified by type only.</p>

<pre><code class="language-erlang">-spec plist_to_map(Ls) -&gt; #{ binary() =&gt; integer() } when
      Ls :: [{binary(), integer()}].

plist_to_map([], M) -&gt;
    M;
plist_to_map([{K,V}|Ls], M) when is_binary(K), is_integer(V) -&gt;
    plist_to_map(Ls, M#{ K =&gt; V });
plist_to_map([_|Ls], M) -&gt;
    plist_to_map(Ls, M).
</code></pre>

<p>It can similarly be specified as a type.</p>

<pre><code class="language-erlang">-type map1() :: #{ binary() =&gt; integer() }.
-type map2() :: #{ &lt;&lt;"list1"&gt;&gt; | &lt;&lt;"list2"&gt;&gt; =&gt; [numbers()] }.
</code></pre>
      <h2 id="functions-and-semantics">
        
        
          Functions and Semantics <a href="#functions-and-semantics">#</a>
        
        
      </h2>
    

<p><em>The module implementing the functions is currently named in plural, <code>maps</code> in the
same spirit as <code>lists</code>, <code>gb_trees</code>, <code>sets</code> etc but the singular <code>map</code> is shorter
and may be more desirable.</em></p>

<p>Functions and semantics for maps. Originally much inspiration was from
Richard O’Keefes frames proposal.</p>
      <h3 id="erlang-module-extension">
        
        
          Erlang module extension <a href="#erlang-module-extension">#</a>
        
        
      </h3>
    
      <h5 id="erlangis_mapm--term---boolean">
        
        
          <code>erlang:is_map(M :: term()) -&gt; boolean().</code> <a href="#erlangis_mapm--term---boolean">#</a>
        
        
      </h5>
    

<p>This function is a guard function.</p>

<p>Syntax equivalence: <code>try #{} = M, true catch error:{badmatch,_} -&gt; false end</code>.</p>

<p>The function returns <code>true</code> if M is a map otherwise <code>false</code>.</p>
      <h5 id="erlangmap_sizem--map---non_neg_integer">
        
        
          <code>erlang:map_size(M :: map()) -&gt; non_neg_integer().</code> <a href="#erlangmap_sizem--map---non_neg_integer">#</a>
        
        
      </h5>
    

<p>This function is a guard function.</p>

<p>Syntax equivalence: <em>none</em>.</p>

<p>The function returns the number of key-value pairs in the map.
  This operation happens in constant time.</p>

<p>Same as <code>maps:size(M)</code>.</p>
      <h3 id="maps-module">
        
        
          maps module <a href="#maps-module">#</a>
        
        
      </h3>
    
      <h5 id="mapsremovek0--term-m0--map---m1--map">
        
        
          <code>maps:remove(K0 :: term(), M0 :: map()) -&gt; M1 :: map().</code> <a href="#mapsremovek0--term-m0--map---m1--map">#</a>
        
        
      </h5>
    

<p>Syntax equivalence: <code>#{ K =&gt; V || K := V &lt;- M0, K =/= K0 }</code>.
  <em>Only with comprehensions</em></p>

<p>The function removes the key <code>K0</code>, if it exists, and its associated value from
  map <code>M0</code> and returns a new map <code>M1</code> without key <code>K0</code>.</p>

<p>Same as, <code>maps:from_list([{K,V}||{K,V} &lt;- maps:to_list(M0), K =/= K0])</code></p>
      <h5 id="mapsgetk--term-m--map---v--term">
        
        
          <code>maps:get(K :: term(), M :: map()) -&gt; V :: term().</code> <a href="#mapsgetk--term-m--map---v--term">#</a>
        
        
      </h5>
    

<p>Syntax equivalence: <code>M#{ K }</code>.</p>

<p>Returns the value <code>V</code> associated with key <code>K</code> if map <code>M</code> contains a key
  that <em>matches</em> <code>K</code>.  If no value is associated with key <code>K</code> then the call will
  fail with an exception.</p>
      <h5 id="mapskeysm--map---k1--kn">
        
        
          <code>maps:keys(M :: map()) -&gt; [K1, .., Kn].</code> <a href="#mapskeysm--map---k1--kn">#</a>
        
        
      </h5>
    

<p>Syntax equivalence: <code>[K || K := _ &lt;- M]</code>.</p>

<p>Returns a complete list of Keys, in arbitrary order, which resides within
  map <code>M</code>.</p>

<p>Same as, <code>[K || {K,_} &lt;- maps:to_list(M)]</code>.</p>
      <h5 id="mapsfindk--term-m--map---ok-v--term--error">
        
        
          <code>maps:find(K :: term(), M :: map()) -&gt; {ok, V :: term()} | error.</code> <a href="#mapsfindk--term-m--map---ok-v--term--error">#</a>
        
        
      </h5>
    

<p>Syntax equivalence: <code>try #{ K := V } = M, V catch error:{badmatch,_} -&gt; error end</code>.</p>

<p>Returns a tuple <code>{ok, V}</code> with value <code>V</code> associated with key <code>K</code> if map <code>M</code>
  contains key <code>K</code>.  If no value is associated with key <code>K</code> then the function
  will return <code>error</code>.</p>
      <h5 id="mapsfoldf--funk--term-v--term-in--term---out--term-a--term-m--map---result--term">
        
        
          <code>maps:fold(F :: fun((K :: term(), V :: term(), In :: term()) -&gt; Out :: term()), A :: term(), M :: map()) -&gt; Result :: term().</code> <a href="#mapsfoldf--funk--term-v--term-in--term---out--term-a--term-m--map---result--term">#</a>
        
        
      </h5>
    

<p>Syntax equivalence: <em>none</em></p>

<p>Calls <code>F(K, V, In)</code> for every key <code>K</code> to value <code>V</code> association in map <code>M</code> in
  arbitrary order. The function fun <code>F/3</code> must return a new accumulator
  which is passed to the next successive call. <code>maps:fold/3</code> returns the final
  value of the accumulator. The initial accumulator value <code>A</code> is returned if
  the map is empty.</p>

<p>Same as, <code>lists:foldl(fun({K,V}, In) -&gt; F(K,V,In) end, A, maps:to_list(M))</code>.</p>
      <h5 id="mapsfrom_listk1v1--knvn---m--map">
        
        
          <code>maps:from_list([{K1,V1}, .., {Kn,Vn}]) -&gt; M :: map().</code> <a href="#mapsfrom_listk1v1--knvn---m--map">#</a>
        
        
      </h5>
    

<p>Syntax equivalence: <code>#{ K1 =&gt; V1, .., Kn =&gt; Vn }</code></p>

<p>The function takes a list of key-value tuples elements and builds a
  map. The associations may be in any order and both keys and values in the
  association may be of any term. If the same key appears more than once,
  the latter (rightmost) value is used and the previous values are ignored.</p>
      <h5 id="mapsis_keyk--term-m--map---bool">
        
        
          <code>maps:is_key(K :: term(), M :: map()) -&gt; bool().</code> <a href="#mapsis_keyk--term-m--map---bool">#</a>
        
        
      </h5>
    

<p>Syntax equivalence: <code>try #{ K := _ } = M, true catch error:{badmatch, _} -&gt; false end</code>.</p>

<p>Returns <code>true</code> if map <code>M</code> contains a key that <em>matches</em> <code>K</code>.</p>
      <h5 id="mapsmapf--function-m0--map---m1--map">
        
        
          <code>maps:map(F :: function(), M0 :: map()) -&gt; M1 :: map().</code> <a href="#mapsmapf--function-m0--map---m1--map">#</a>
        
        
      </h5>
    

<p>Syntax equivalence: <code>#{ K =&gt; F(K,V) || K := V &lt;- M }</code>.
  <em>Only with comprehensions</em></p>

<p>The function produces a new map <code>M1</code> by calling the function fun <code>F(K, V)</code> for
  every key <code>K</code> to value <code>V</code> association in map <code>M0</code> in arbitrary order.
  The function fun <code>F/2</code> must return the value to be associated with key <code>K</code> for
  the new map <code>M1</code>.</p>

<p>Same as, <code>maps:from_list(lists:map(fun({K,V}) -&gt; {K, F(K,V)} end, maps:to_list(M)))</code>.</p>
      <h5 id="mapsnew---m--map">
        
        
          <code>maps:new() -&gt; M :: map().</code> <a href="#mapsnew---m--map">#</a>
        
        
      </h5>
    

<p>Syntax equivalence: <code>#{}</code>.</p>

<p>Returns a new empty map.</p>

<p>Same as, <code>maps:from_list([])</code>.</p>
      <h5 id="mapssizem--map---size--non_neg_integer">
        
        
          <code>maps:size(M :: map()) -&gt; Size :: non_neg_integer().</code> <a href="#mapssizem--map---size--non_neg_integer">#</a>
        
        
      </h5>
    

<p>Syntax equivalence: <em>none</em>.</p>

<p>The function returns the number of key-value associations in the map.
  This operation happens in constant time.</p>

<p>Same as <code>erlang:map_size(M)</code>.</p>
      <h5 id="mapsputk--term-v--term-m0--map---m1--map">
        
        
          <code>maps:put(K :: term(), V :: term(), M0 :: map()) -&gt; M1 :: map().</code> <a href="#mapsputk--term-v--term-m0--map---m1--map">#</a>
        
        
      </h5>
    

<p>Syntax equivalence: <code>M0#{ K =&gt; V }</code>.</p>

<p>Associates key <code>K</code> with value <code>V</code> and inserts the association into map <code>M0</code>.
  If a key exists that <em>matches</em> <code>K</code>, the old associated value is
  replaced by value <code>V</code>.
  The function returns a new map <code>M1</code> containing the new association.</p>

<p>Same as, <code>maps:from_list(maps:to_list(M0) ++ [{K,V}])</code>.</p>
      <h5 id="mapsto_listm--map---k1v1--knvn">
        
        
          <code>maps:to_list(M :: map()) -&gt; [{K1,V1}, ..., {Kn,Vn}].</code> <a href="#mapsto_listm--map---k1v1--knvn">#</a>
        
        
      </h5>
    

<p>Syntax equivalence: <code>[{K, V} || K := V &lt;- M]</code>.</p>

<p>Where the pairs, <code>[{K1,V1}, ..., {Kn,Vn}]</code>, are returned in arbitrary order.</p>
      <h5 id="mapsupdatek--term-v--term-m0--map---m1--map">
        
        
          <code>maps:update(K :: term(), V :: term, M0 :: map()) -&gt; M1 :: map()</code> <a href="#mapsupdatek--term-v--term-m0--map---m1--map">#</a>
        
        
      </h5>
    

<p>Syntax equivalence: <code>M0#{ K := V }</code>.</p>

<p>If a key exists that <em>matches</em> <code>K</code>, the old associated value is
  replaced by value <code>V</code>. The function returns a new map <code>M1</code> containing
  the new associated value.</p>

<p>Same as, <code>maps:from_list(maps:to_list(M0) ++ [{K,V}])</code>.</p>
      <h5 id="mapsvaluesm--map---v1--vn">
        
        
          <code>maps:values(M :: map()) -&gt; [V1, .., Vn].</code> <a href="#mapsvaluesm--map---v1--vn">#</a>
        
        
      </h5>
    

<p>Syntax equivalence: <code>[V || _ := V &lt;- M]</code>.</p>

<p>Returns a complete list of values, in arbitrary order, contained in map <code>M</code>.</p>

<p>Same as, <code>[V || {_,V} &lt;- maps:to_list(M)]</code>.</p>
      <h5 id="mapswithoutk1--kn--ks-m0--map---m1--map">
        
        
          <code>maps:without([K1, .., Kn] = Ks, M0 :: map()) -&gt; M1 :: map().</code> <a href="#mapswithoutk1--kn--ks-m0--map---m1--map">#</a>
        
        
      </h5>
    

<p>Syntax equivalence: <code>#{ K =&gt; V || K := V &lt;- M0, not lists:member(K, Ks) }</code>. 
  <em>Only with comprehensions</em></p>

<p>Removes keys <code>K1</code> through <code>Kn</code>, and their associated values, from map <code>M0</code> and
  returns a new map <code>M1</code>.</p>

<p>Same as, <code>maps:from_list([{K,V}||{K,V} &lt;- maps:to_list(M0), not lists:member(K, Ks)])</code>.</p>
      <h5 id="mapsmergem0--map-m1--map---m2--map">
        
        
          <code>maps:merge(M0 :: map(), M1 :: map()) -&gt; M2 :: map().</code> <a href="#mapsmergem0--map-m1--map---m2--map">#</a>
        
        
      </h5>
    

<p>Syntax equivalence: <em>none</em></p>

<p>Merges two maps into a single map. If two <em>matching</em> keys exists in both maps the
  value in map <code>M0</code> will be superseded by the value in map <code>M1</code>.</p>
      <h2 id="equality-and-ordering">
        
        
          Equality and Ordering <a href="#equality-and-ordering">#</a>
        
        
      </h2>
    
      <h3 id="equality">
        
        
          Equality <a href="#equality">#</a>
        
        
      </h3>
    

<p>In the case of term <code>A</code> and term <code>B</code> both are maps,</p>

<ul>
  <li>If <code>A</code> and <code>B</code> have different sizes, then <code>A</code> and <code>B</code> are not equal.</li>
  <li>Otherwise, if all corresponding keys of <code>A</code> and <code>B</code> are pair-
wise equal with their corresponding values, then <code>A</code> and <code>B</code> are equal.</li>
  <li>Otherwise, <code>A</code> and <code>B</code> are not equal.</li>
</ul>

<p>It follows that two maps are equal if, and only if, they are of
the same, <em>type</em>, <em>size</em> and all corresponding key-value associations are
pairwise equal.</p>
      <h3 id="ordering">
        
        
          Ordering <a href="#ordering">#</a>
        
        
      </h3>
    

<p>The term order is defined in <a href="http://www.Erlang.org/download/erl_spec47.ps.gz" title="Erlang specification 4.7">Erlang specification 4.7</a> and quoted
below:</p>

<blockquote class='blockquote'>
  <ul>
    <li>
      <p>The terms are primarily ordered according to their type, in the following order:</p>

      <pre><code>  numbers &lt; atoms &lt; refs &lt; ports &lt; PIDs &lt; tuples &lt; empty list &lt; conses &lt; binary
</code></pre>
    </li>
  </ul>
</blockquote>

<p>The specification is incomplete here, the actual term order is:</p>

<pre><code class="language-erlang">numbers &lt; atoms &lt; refs &lt; funs &lt; ports &lt; pids &lt; tuples &lt; empty list &lt; conses &lt; binaries
</code></pre>

<p>The Maps data-type are ordered next after tuples:</p>

<pre><code class="language-erlang">numbers &lt; atoms &lt; refs &lt; funs &lt; ports &lt; pids &lt; tuples &lt; maps &lt; empty list &lt; conses &lt; binaries
                                                        ----
</code></pre>

<p>Maps are then ordered first by their size and then according to their
respective keys and lastly by the associated values in Erlang term order.</p>

<p>Given two maps, <code>M1</code> and <code>M2</code>, with the same size, they are compared
so that each key, in Erlang term order of the keys, in <code>M1</code>
is compared to the corresponding key of <code>M2</code>. All keys are
compared first, then the values, until a difference is found. If a key
or value differs, the order of the respective terms, in Erlang term
order, is the order of the maps. If no key-value pairs differ, the
maps are considered equal.</p>

<p>Example:</p>

<pre><code class="language-erlang">&gt; #{ b =&gt; 2 } &gt; #{ a =&gt; 2 }.         % b &gt; a
true
&gt; #{ b =&gt; 2 } &gt; #{ a =&gt; 1, b =&gt; 2 }. % size 1 &lt; size 2
false
&gt; #{ b =&gt; 1 } &gt; #{ b =&gt; 2}.          % 1 &lt; 2
false
&gt; #{ b =&gt; 2, c =&gt; 3 } &gt; #{ b =&gt; 1, d =&gt; 3}.  % c &gt; d, compared before 2 and 1
false
&gt; #{ b =&gt; 1 } &gt; #{ 1 =&gt; 1}.          % b &gt; 1
true
&gt; #{ 1.0 =&gt; a } == #{ 1 =&gt; a }.      % 1.0 == 1
true
&gt; #{ 1.0 =&gt; a } =:= #{ 1 =&gt; a }.     % 1.0 =:= 1
false
</code></pre>

<p>Maps are printed with keys in arbitrary order.</p>
      <h2 id="operator-precedence">
        
        
          Operator Precedence <a href="#operator-precedence">#</a>
        
        
      </h2>
    

<p>Map association operator and set-value operator is ordered last,
after match-operator and <code>catch</code>.</p>

<pre><code class="language-erlang">:
#
Unary + - bnot not
/ * div rem band and          Left associative
+ - bor bxor bsl bsr or xor	  Left associative
++ --                         Right associative
== /= =&lt; &lt; &gt;= &gt; =:= =/=
andalso
orelse
= !	                          Right associative
catch	 
=&gt; :=
</code></pre>

<p>It follows that the map expression:</p>

<pre><code class="language-erlang">#{ key =&gt; C = 1 + 2 }
</code></pre>

<p>will evaluate in the following order:</p>

<pre><code class="language-erlang">#{ key =&gt; ( C = ( 1 + 2 ) ) }
</code></pre>
      <h2 id="pattern-matching">
        
        
          Pattern matching <a href="#pattern-matching">#</a>
        
        
      </h2>
    

<p>Pattern matching is very powerful Erlang tool. Maps introduces a couple of new
features with its pattern matching.</p>
      <h3 id="pattern-matching-basics">
        
        
          Pattern matching: Basics <a href="#pattern-matching-basics">#</a>
        
        
      </h3>
    

<p>We will exemplify using the match operator.</p>

<p>Pattern matching with maps is similar to records on the surface. Keys requested
in a LHS pattern will be bound with the values which is found in the
RHS association map.</p>

<pre><code class="language-erlang">1&gt; #{ a := V } = #{ a =&gt; 1 }.
#{ a =&gt; 1 }
2&gt; 1 = V.
1
</code></pre>

<p>Keys requested in a LHS pattern which is not found in the RHS map will produce
an exception, <code>exception error: no match of right hand side value ...</code>.</p>

<pre><code class="language-erlang">1&gt; #{ not_in_map := V } = #{ a =&gt; 1 }.
** exception error: no match of right hand side value #{ a =&gt; 1 }
</code></pre>

<p>Similarly, if a value for a requested key in the LHS pattern
does not match the keys associated value in the RHS map
the match will produce an exception.</p>

<pre><code class="language-erlang">1&gt; #{ a := 10 } = #{ a =&gt; 1 }.
** exception error: no match of right hand side value #{ a =&gt; 1 }
</code></pre>

<p>Only the keys requested will bind to associations. Any unrequested keys which
resides within the map being matched will be ignored.</p>

<pre><code class="language-erlang">1&gt; #{ a := V1, b := V2 } = #{ a =&gt; 1, b =&gt; 2, c =&gt; 3}.
#{ a =&gt; 1, b =&gt; 2, c =&gt; 3 }
2&gt; 1 = V1.
1
3&gt; 2 = V2.
2
</code></pre>

<p>The order of keys requested has no significance when pattern matching a map.</p>

<pre><code class="language-erlang">1&gt; #{ a := "1", b := "2" } = #{ a =&gt; "1", b =&gt; "2" }.
#{ a =&gt; "1", b =&gt; "2" }
2&gt; #{ b := "2", a := "1" } = #{ a =&gt; "1", b =&gt; "2" }.
#{ a =&gt; "1", b =&gt; "2" }
</code></pre>
      <h3 id="pattern-matching-continued">
        
        
          Pattern matching: Continued <a href="#pattern-matching-continued">#</a>
        
        
      </h3>
    

<p>The example below is a constructed example to illustrate the power of map
pattern matching.</p>

<p>A match expression is evaluated so that variables used as keys in the expression
are bound before they are evaluated (if possible).</p>

<p>As an example, keys can be bound by other key-value associations.</p>

<pre><code class="language-erlang">1&gt; #{ K := V, id := K } = M = #{ id =&gt; b, a =&gt; 1, b =&gt; 2, c =&gt; 3}.
#{ id =&gt; b, a =&gt; 1, b =&gt; 2, c =&gt; 3}
2&gt; b = K.
b
3&gt; 2 = V.
2
</code></pre>

<p>In this case, the bound key <code>id</code> is evaluated first and looked up in
M, binding the variable <code>K</code>. The <code>K</code> bound to <code>b</code> can then be used to
bind <code>V</code> to 2.</p>

<p>Binding variables used as keys requires that there is a possible order of
binding without cycles. The reordering extends to all terms in a matching
expression, so that:</p>

<pre><code class="language-erlang">1&gt; { #{ X := Y }, X } = { #{ 5 =&gt; 10 }, 5 }.
</code></pre>

<p>with <code>X</code> and <code>Y</code> unbound, results in a successful match binding <code>X</code> to 5 and
<code>Y</code> to 10.</p>

<p>This is particular useful when updating specifics in map associations:</p>

<pre><code class="language-erlang">%% Function declared in module map_example
update_values([{K, V1}|Ls], #{ K := V0 } = M) -&gt; update_values(Ls, M#{ K := V0 + V1 });
update_values([_|Ls], M) -&gt; update_values(Ls, M);
update_values([], M)     -&gt; M.
</code></pre>

<p>The first function clause is important here. Key <code>K</code> is bound in the tuple and
will be used to request value <code>V0</code> from map <code>M</code>. The map <code>M</code> is then updated to
associate key <code>K</code> with the new value <code>V0 + V1</code>.</p>

<pre><code class="language-erlang">%% In the Erlang shell
1&gt; M = #{ "a" =&gt; 1, "b" =&gt; 2, "c" =&gt; 3 }.
#{ "a" =&gt; 1, "b" =&gt; 2, "c" =&gt; 3 }

2&gt; map_example:update_values([{"b", 10}, {"c", 20}, {"d", 30 }], M).
#{ "a" =&gt; 1, "b" =&gt; 12, "c" =&gt; 23 }
</code></pre>

<p>Note that since key <code>"d"</code> does not reside in map <code>M</code> it fails to match the first
clause and does not update the map with the association <code>"d" =&gt; 40</code>.</p>

<p>An expression where the dependencies in the LHS of the match are cyclic, like:</p>

<pre><code class="language-erlang">1&gt;  #{X := Y, Y := X} = #{5 =&gt; 10, 10 =&gt; 5}.
</code></pre>

<p>will result in an evaluator error (variable is unbound) or a compilation error.</p>
      <h2 id="external-term-format">
        
        
          External Term Format <a href="#external-term-format">#</a>
        
        
      </h2>
    

<p>There are 255 tags that can be used to encode terms for external binary
distribution.  All tags are defined in <code>external.h</code>. The encoding starts by a
magic byte <code>131</code>.</p>

<p>The encoding tags used in R15B01 are the following:</p>

<pre><code class="language-erlang">SMALL_INTEGER_EXT        'a'     97
INTEGER_EXT              'b'     98
FLOAT_EXT                'c'     99 
ATOM_EXT                 'd'    100
SMALL_ATOM_EXT           's'    115
REFERENCE_EXT            'e'    101
NEW_REFERENCE_EXT        'r'    114
PORT_EXT                 'f'    102
NEW_FLOAT_EXT            'F'     70
PID_EXT                  'g'    103
SMALL_TUPLE_EXT          'h'    104
LARGE_TUPLE_EXT          'i'    105
NIL_EXT                  'j'    106 
STRING_EXT               'k'    107
LIST_EXT                 'l'    108 
BINARY_EXT               'm'    109 
BIT_BINARY_EXT           'M'     77                                         
SMALL_BIG_EXT            'n'    110
LARGE_BIG_EXT            'o'    111
NEW_FUN_EXT              'p'    112 
EXPORT_EXT               'q'    113
FUN_EXT                  'u'    117
            
DIST_HEADER              'D'     68
ATOM_CACHE_REF           'R'     82
ATOM_INTERNAL_REF2       'I'     73
ATOM_INTERNAL_REF3       'K'     75
BINARY_INTERNAL_REF      'J'     74
BIT_BINARY_INTERNAL_REF  'L'     76
COMPRESSED               'P'     80
</code></pre>

<p>For Maps we define tag <code>MAP_EXT</code> to 116 (<code>t</code>).</p>

<p>Data layout:</p>

<pre><code class="language-erlang">MAP_EXT
|-----------------------------------	
|  1  |    4   |        |          |
|-----------------------------------
| 116 |  Size  |  Keys  |  Values  |
|-----------------------------------
</code></pre>

<p>The <code>Size</code> specifies the number of keys and values that follows the size
descriptor.</p>

<p>An open questions, optimize for:</p>

<ol>
  <li>encoding/decoding speed?</li>
  <li>ease of access?</li>
  <li>memory size?</li>
</ol>

<p>Memory size should be a priority since we send this data over the wire. We
should promote ease of access so other languages can integrate towards the
format.</p>

<p>This leads to a flat and simple structure. It follows that encoding/decoding
takes a performance hit.</p>
      <h1 id="motivation">
        
        
          Motivation <a href="#motivation">#</a>
        
        
      </h1>
    

<p>Why would we need maps when we have <em>records</em>, <em>dicts</em>, <em>gb_trees</em>, <em>ets</em>
and <em>proplists</em>?</p>

<p>Maps are envisioned to be an easy to use, lightweight yet powerful key-value
association store.</p>

<p>Maps utilizes one of Erlang’s major strengths, pattern matching, to enrich user
experience and provide a powerful tool to simplify code development. Pattern
matching gives Maps a clear edge over dicts, gb_trees or proplists in usability.</p>

<p>Maps provides the possibility to associate arbitrary terms as keys, not only
atoms, with arbitrary terms as values in a matching capable data-type.</p>

<p>Maps does not claim to be an replacement to records as the frames proposal does.
Instead maps targets a larger usage domain and wishes to be a complement to
records and supersede them where suitable.</p>
      <h3 id="maps---two-approaches">
        
        
          Maps - Two approaches <a href="#maps---two-approaches">#</a>
        
        
      </h3>
    

<ol>
  <li>Maps as an association array with pattern matching and syntax for
constructing, accessing or updating them.</li>
  <li>Maps as a record replacement.</li>
</ol>

<p>Maps were not envisioned as a record replacement at first, it was a hopeful
requirement added later. A record replacement approach does not necessarily
restrain any semantics but it may put some constraint on the implementation
and underlying structure.</p>
      <h5 id="records">
        
        
          Records <a href="#records">#</a>
        
        
      </h5>
    

<p>Records are powerful under the right circumstances:</p>

<ul>
  <li>fast lookups, O(1), due to compile time indexing of keys, and fast stores for
small record sizes (~50 values),</li>
  <li>no memory overhead to store keys, only values and a name: 2 + N words
consumption,</li>
  <li>ease of use in function head matching.</li>
</ul>

<p>However some of the drawbacks are:</p>

<ul>
  <li>compile-time dependency and forces header file inclusions for inter-module usage,</li>
  <li>only atoms as keys,</li>
  <li>keys are not accessible in runtime,</li>
  <li>no dynamic access of values, i.e. we cannot use variables to access values,</li>
  <li>it is not a data-type and cannot be distinguished from tuples.</li>
</ul>

<p>When comparing maps with records the drawbacks are easily remedied by Maps,
however the positive effects is not as easy to replicate in a built-in data-type
where values are determined at runtime instead of at compile time.</p>

<ul>
  <li>Being faster than direct-indexing array, where indices and possibly the
resulting value are determined at compile time, is hard.
In fact it is impossible.</li>
  <li>A memory model for Maps where the efficiency was near that of records
could be achieved by essentially using two tuples, one for keys and one for
values as demonstrated in Frames. This would be impact performance of
updates on Maps with a large number of entries and thus constrain the
capability of a dictionary approach.</li>
  <li>Maps would be as easy, or even easier, to use with matching in function heads.</li>
</ul>
      <h3 id="protocol-construction">
        
        
          Protocol Construction <a href="#protocol-construction">#</a>
        
        
      </h3>
    

<p>Arguments for a simpler a JSON representation using frames or 
maps has been raised. Using frames and thereby atoms for dynamic creation of keys
would be a serious drawback.  Using maps would grant the possibility of string
binaries to represent keys and would not put the global atom pool in disarray.</p>
      <h4 id="pattern-matching-example-the-json-files">
        
        
          Pattern Matching Example: The JSON Files <a href="#pattern-matching-example-the-json-files">#</a>
        
        
      </h4>
    

<p>Changing json-decoding. Mochiwebs mochijson decodes Json dictionaries the as
the following:</p>

<pre><code class="language-erlang">{"key": "value"} -&gt; {struct, [{"key", "value"}]}
</code></pre>

<p>This could instead be:</p>

<pre><code class="language-erlang">{"key": "value"} -&gt; #{ "key" =&gt; "value"}
</code></pre>

<p>Consider the following JSON examples, from <a href="http://json.org/example.html" title="JSON Example">json.org</a>.</p>

<pre><code class="language-erlang">{"menu": {
  "id": "file",
  "value": "File",
  "popup": {
    "menuitem": [
      {"value": "New", "onclick": "CreateNewDoc()"},
      {"value": "Open", "onclick": "OpenDoc()"},
      {"value": "Close", "onclick": "CloseDoc()"}
    ]
  }
}}
</code></pre>

<p><code>mochijson:decode/1</code> will currently look like:</p>

<pre><code class="language-erlang">{struct, [
    {"menu", {struct, [
        {"id","file"},
        {"value","File"},
        {"popup", {struct, [
            {"menuitem", {array, [
                {struct, [{"value","New"},{"onclick","CreateNewDoc()"}]},
                {struct, [{"value","Open"},{"onclick","OpenDoc()"}]},
                {struct, [{"value","Close"}, {"onclick","CloseDoc()"}]}
            ]}}
        ]}}
    ]}}
]}
</code></pre>

<p><code>mochijson:decode/1</code> could look like:</p>

<pre><code class="language-erlang">#{ "menu" =&gt; #{
    "id" =&gt; "file",
    "value" =&gt; "File",
    "popup" =&gt; #{
        "menuitem" =&gt; [
          #{ "value" =&gt; "New",   "onclick" =&gt; "CreateNewDoc()"},
          #{ "value" =&gt; "Open",  "onclick" =&gt; "OpenDoc()"},
          #{ "value" =&gt; "Close", "onclick" =&gt; "CloseDoc()"}
        ]
    }
}}
</code></pre>

<p>Let us find <code>"menu"</code> -&gt; <code>"popup"</code> -&gt; <code>"menuitem"</code>.</p>

<p>Traversing the first structure is a bit awkward. We would have to do
the following:</p>

<pre><code class="language-erlang">Decoded         = mochijson:decode(Json),
{struct, Menu}  = proplists:get_value("menu", Decoded),
{struct, PopUp} = proplists:get_value("popup", Menu),
{struct, Items} = proplists:get_value("menuitem", PopUp),
</code></pre>

<p>With maps it could look like the following:</p>

<pre><code class="language-erlang">#{ "menu"     := Menu  } = mochijson:decode(Json),
#{ "popup"    := PopUp } = Menu,
#{ "menuitem" := Items } = PopUp,
</code></pre>

<p>or even:</p>

<pre><code class="language-erlang">Decoded = mochijson:decode(Json),
#{ "menu" := #{ "popup" := #{ "menuitem" := Items } } } = Decoded,
</code></pre>

<p>With maps, and single value access, it could look really simple:</p>

<pre><code class="language-erlang">Decoded = mochijson:decode(Json),
Items = Decoded#{ "menu" }#{ "popup" }#{ "menuitem "}.
</code></pre>
      <h3 id="open-questions">
        
        
          Open Questions <a href="#open-questions">#</a>
        
        
      </h3>
    

<p>We have some usage scenarios that are still open for debate. A proposed answer
is given for each question and stems from discussions in this proposal.</p>

<ol>
  <li>What type of keys will we need to store in our Map? Will atoms suffice?
    <ul>
      <li>It is the authors view that we should refrain from any key restrictions
  unless there is overwhelmingly evidence that we can gain something from
  such a restriction.</li>
      <li>A non atom key restriction satisfies our goal of a powerful Map mechanism.</li>
      <li>Proposal: <em>Any term as keys.</em></li>
    </ul>
  </li>
  <li>How many key-value associations will we store in our map?
    <ul>
      <li>This question has less to do with syntax and semantics than it has with
  the choice of the underlying implementation.</li>
      <li>If we enable the user to add key-value pairs dynamically surely he will
  use it.  Since it is a powerful mechanism not afforded to us by records
  the usage pattern will also be different. This will in all likelihood
  produce larger Maps than records are today. This implies that we cannot
  compare records sizes with that of maps sizes since the usage scenario
  would be different.</li>
      <li>Proposal: <em>Arbitrary number of keys-value pairs.</em></li>
    </ul>
  </li>
  <li>How many Map instances will we create for each Map with a specific set of keys?
    <ul>
      <li>This question is closely related to how we use records and if Maps should
  emulate this behavior and this should have no impact on semantics, only
  implementation.</li>
      <li>The significant difference is the memory overhead in the storing structure.
  Since memory overhead for keys and values has the same behavior as in any
  compound term or abstract data-type, i.e. dict or gb_trees, the main
  difference occurs when comparing maps to records and frames. To ensure a
  logarithmic worst-case performance in update or retrieval some sort tree
  structure would likely be used for maps. Maps would then stores keys
  together with its values whereas frames stores keys outside its value
  structure and records generates key indexes at compile-time. This would
  indicate a memory overhead for Maps over Frames and records for each
  instance.</li>
      <li>Proposal: <em>Two tier approach, similar to binaries. Use flat compact,
  key-sharing approach for few associations (~50 associations). Use sorted
  tree approach and store keys with values beyond first tier limit.
  The rationale being it is more likely to have multiple instance where
  we have few keys.</em></li>
    </ul>
  </li>
  <li>Only allow updates of already defined keys within a Map in syntax?
    <ul>
      <li>The question stems from a record replacement approach and the argument for
  it is to mitigate typos, i.e. trying to update key <code>behavior</code> where key
  <code>behaviour</code> was actually intended. Instead of getting two different keys,
  a runtime exception occurs at this point.</li>
      <li>This approach will <em>deny</em> any dictionary like behavior, for instance
  storing spawned processes as keys in the map using syntax.</li>
      <li>Proposal: <em>Allow for any key to be stored by default syntax,
  existing or not, and use a special syntax for setting of values of
  existing keys only.</em></li>
    </ul>
  </li>
</ol>

<p>The answers from these questions are instrumental to how we should design and
implement Maps. What we also should keep in the back of our minds is that we
will never get rid of records completely and some of the frames arguments might
thus be superfluous.</p>
      <h1 id="rationale">
        
        
          Rationale <a href="#rationale">#</a>
        
        
      </h1>
    
      <h2 id="what-should-we-expect-from-our-syntax">
        
        
          What should we expect from our syntax? <a href="#what-should-we-expect-from-our-syntax">#</a>
        
        
      </h2>
    

<p>As stated earlier, the current syntax is not set in stone but what should we
expect from it?</p>

<ol>
  <li>
    <p>First and foremost it has to be unambiguous, meaning the syntax must produce
single clearly defined behavior that cannot be misinterpreted by humans
nor machines.</p>

    <p>1.1  Here we also include the notion that similar syntax should have similar
     behavior, or at least not completely different behavior.
     For example records, <code>#record{ key = Value }</code>, have O(1) performance and
     2 + N words memory overhead.  If we use a similar syntax,
     i.e. <code>#{ key = Value }</code>, we should also expect similar behavior both in
     regard to semantics and performance for any and all sizes of the map.</p>
  </li>
  <li>
    <p>The syntax must be as short as possible. It must not use more characters than
necessary to describe a certain behavior as long as it
does not violate rule 1.</p>

    <p>2.2  We want to avoid verbosity in the language. Verbosity pushes away
information from our field of vision and obfuscates it.
This needs to be avoided.</p>
  </li>
</ol>
      <h2 id="syntax-choice-for-maps">
        
        
          Syntax choice for Maps <a href="#syntax-choice-for-maps">#</a>
        
        
      </h2>
    

<p><em>The author argues for:</em> <code>=&gt;</code> <em>as delimiter in ‘set-or-update’ and</em>
<code>:=</code> <em>in ‘set-existing’ and ‘matching’ syntax.</em></p>

<p>In the examples below we use <code>#{ Key =&gt; Value }</code> to describe map semantics and
use-cases, but this is only one suggestion out of many.</p>

<p>Several syntax proposals exists, frames proposes <code>&lt;{ key ~ Value }&gt;</code> syntax and
another syntax suggestion is very similar to record syntax <code>#{ key = Value }</code>.</p>

<p>The current variable and atom definitions puts restrictions on what we can use
as delimiters and leaves us <code>~</code> and <code>=</code> as the only sane <em>single</em> character
delimiters we can use. The case is very well argued in Richard O’Keefes
<a href="http://www.cs.otago.ac.nz/staffpriv/ok/frames.pdf" title="No more need for records">No more need for records (fifth draft)</a>.</p>
      <h3 id="delimiter-discussion">
        
        
          Delimiter discussion <a href="#delimiter-discussion">#</a>
        
        
      </h3>
    

<p>Arguments against a <code>=</code> delimiter are:</p>

<ul>
  <li>It lacks distinction from match, consider <code>#{ A = B = v }</code>,
does <code>A</code> match <code>B</code> or does <code>B</code> match <code>v</code>?
Which <code>=</code> is a match operation and which <code>=</code> delimits the key-value pair?</li>
  <li>It might be interpreted as <code>Key</code> ‘equal’ <code>Value</code>,</li>
</ul>

<p>and hence <code>=</code> is in violation of rule #1 from <em>What do we expect from our syntax?</em>.
The interpretation of this syntax is ambiguous.</p>

<p>Arguments against a <code>~</code> delimiter are:</p>

<ul>
  <li>it might be interpreted as <code>Key</code> ‘NOT’ <code>Value</code>
as <code>~</code> is the bitwise NOT operator in C,</li>
  <li>it might be interpreted as <code>Key</code> ‘about equal’ <code>Value</code>
as <code>~</code> is similar to mathematics <code>≃</code>,</li>
  <li>it lacks typographical distinction,
i.e. it lacks distinction from <code>-</code> in certain fonts, 
ex. <code>K ~ V</code> might be interpreted as <code>K - V</code>, consider <code>#{ K - 1 ~ 2 - V }</code>,</li>
</ul>

<p>and hence this is in violation of rule #1 from <em>What do we expect from our syntax?</em>.
The interpretation of this syntax is ambiguous.</p>

<p>Two two-character delimiter suggestions are <code>#{ Key := Value }</code> and
<code>#{ Key =&gt; Value}</code>, where <code>:=</code> is a common denominator for assignment and <code>=&gt;</code>
should be read as <em>maps to</em>. A two-character delimiter should be avoided if at
all possible since it increases the syntax footprint of the source code.</p>

<p>The assignment delimiter reads well for just assignment but suffers from the
same reversed logic flaw as records when it comes to pattern matching. The match
<code>#{ key := Value } = M</code> reads <em>match M to the map pattern where Value is equal
to key</em>. That does not read well unless we call the assignment delimiter <code>:=</code>
for something that its not meant to be.</p>

<p>However, <code>:=</code> is also similar to <code>=:=</code> which means “is exactly equal”,
i.e. matches. This is a valuable meaning since we have a difference
between <code>==</code> and <code>=:=</code> when dealing with numbers and thus <code>:=</code> could be a more
correct delimiter for matching syntax.</p>

<p>The delimiter <code>-&gt;</code> would be suitable choice if it weren’t for the fact that it
would overload the function clause meaning.</p>

<p>Both <code>-&gt;</code> and <code>=&gt;</code> might be confusing when dealing with binaries.
Consider <code>#{ &lt;&lt;"key"&gt;&gt; -&gt; &lt;&lt;"value"&gt;&gt; }</code> and <code>#{ &lt;&lt;"key"&gt;&gt; =&gt; &lt;&lt;"value"&gt;&gt; }</code>,
where <code>=&gt;</code> appears to be slightly more confusing than <code>-&gt;</code>.</p>

<p>Listing of delimiters from above perceived desirability:</p>

<ol>
  <li><code>#{ K =&gt; V }</code> - No ambiguity, no overloading, reads as an association</li>
  <li><code>#{ K := V }</code> - No ambiguity, no overloading, reads as an assignment or exact match</li>
  <li><code>#{ K ~ V }</code>  - Typographical ambiguity, no overloading, no clear meaning</li>
  <li><code>#{ K -&gt; V }</code> - Overloads function clause head and body separator, reads as an association</li>
  <li><code>#{ K = V }</code>  - Overloads match operator, reads as a match or an assignment</li>
</ol>

<p>Using <code>:=</code> assignment for existing keys seems as a good choice. The choice for
set-or-update is between <code>=&gt;</code> and <code>~</code>.</p>
      <h3 id="the-case-for-two-set-or-update-semantics-and-its-syntax">
        
        
          The case for two set-or-update semantics and its syntax <a href="#the-case-for-two-set-or-update-semantics-and-its-syntax">#</a>
        
        
      </h3>
    

<p>A case for two different ways to update values in a Map is proposed.</p>

<p>One syntax if, and only if, we want to update a value for an already <em>existing</em>
key and another if we want to update the Map with any key.</p>

<ul>
  <li>Use <code>M#{ K =&gt; V }</code> to declare new key value pairs <em>or</em> update already existing keys</li>
  <li>Use <code>M#{ K := V }</code> to update already existing keys.</li>
  <li>Use ` #{ K := V } = M` to match maps.</li>
</ul>

<p>Example 1:</p>

<pre><code class="language-erlang">foo() -&gt;
    M = #{ key1 =&gt; 1, key2 =&gt; 2 }, % M is declared with keys 'key1' and 'key2'
    bar(M).

bar(M) -&gt;
    M#{
        key1 := "1",  %% 'key1' will be set to "1"
        key2 := "2",  %% 'key2' will be set to "2"
        key3 := "3"   %% this causes an exception since 'key3' does not exist in M
    }.

&gt; foo().
** exception error: no match of 'key3' in map
</code></pre>

<p>Example 2:</p>

<pre><code class="language-erlang">foo() -&gt;
    M = #{ key1 =&gt; 1, key2 =&gt; 2 }, % M is declared with keys 'key1' and 'key2'
    bar(M).

bar(M) -&gt;
    M#{
        key1 =&gt; "1",  %% 'key1' will be set to "1"
        key2 =&gt; "2",  %% 'key2' will be set to "2"
        key3 =&gt; "3"   %% 'key3' will be set to "3"
    }.

&gt; foo().
#{ key1 =&gt; 1, key2 =&gt; "2", key3 =&gt; "3" }
</code></pre>
      <h2 id="impact-of-syntax-footprint">
        
        
          Impact of syntax footprint <a href="#impact-of-syntax-footprint">#</a>
        
        
      </h2>
    

<p>We must lessen the syntax footprint impact on the source code and the language.</p>

<p>Currently the two normal ways of sending options to a functions are either via
records or property lists. Both have some drawbacks. Records are compile time
dependent and syntactic sugar for tuples. Property lists are generic but
produces a lot of texts when defining them and operating on them.</p>

<p>Consider this example when parsing a list of arguments:</p>

<pre><code class="language-erlang">args(Args) -&gt; 
     args(Args, [{analyze, false}, {suppression, false}, {target, none}]).

args(["-r" | Args], Opts) -&gt; 
    args(Args, [{analyze, true}     | proplists:delete(analyze, Opts)]);
args(["-s="++File | Args], Opts) -&gt; 
    args(Args, [{suppression, File} | proplists:delete(suppression, Opts)]);
args([Target], Opts) -&gt; 
    [{target, Target} | proplists:delete(target, Opts)].
</code></pre>

<p>The textual impact, the number of characters, is quite heavy when operating on 
property lists.</p>

<p>If we instead use some kind of map with syntax, how would that look?</p>

<pre><code class="language-erlang">args(Args) -&gt; 
    args(Args, #{ analyze =&gt; false, suppression =&gt; false, target =&gt; none}).

args(["-r" | Args], Opts)        -&gt; args(Args, Opts#{ analyze := true });
args(["-s="++File | Args], Opts) -&gt; args(Args, Opts#{ suppression := File});
args([Target], Opts)             -&gt; Opts#{ target := Target }.
</code></pre>

<p>This looks cleaner in my opinion but that is a very subjective view. To use some
data we can count the characters, and we see that the property lists example has
390 characters versus the map examples 306. Property lists uses almost 30% more
characters in this example.</p>
      <h2 id="semantics-and-api-functions">
        
        
          Semantics and API-functions <a href="#semantics-and-api-functions">#</a>
        
        
      </h2>
    
      <h3 id="list-conversions">
        
        
          List conversions <a href="#list-conversions">#</a>
        
        
      </h3>
    

<p>Perhaps the most sane <code>maps:from_list/1</code> semantics would be to have the key-value
significance order in left to right, meaning the first association is used and
the latter values with matching keys are ignored.</p>

<p>This differs from the <code>dict:from_list/1</code> behavior.</p>

<p>Consider the following <code>dict</code> example:</p>

<pre><code class="language-erlang">[{a,2}] = dict:to_list(dict:from_list([{a,1}, {a,2}])).
</code></pre>

<p>By letting the leftmost be the most significant key we could simplify conversion
from and to lists.</p>

<p>Current suggestion has the following semantics:</p>

<pre><code class="language-erlang">Ls = [{a,old}],
#{ a := old } = maps:from_list([{a,new}|Ls]).
</code></pre>

<p>The reversal would be:</p>

<pre><code class="language-erlang">Ls = [{a,old}],
#{ a := new } = maps:from_list([{a,new}|Ls]).
</code></pre>
      <h2 id="equality-and-ordering-1">
        
        
          Equality and Ordering <a href="#equality-and-ordering-1">#</a>
        
        
      </h2>
    

<p>A restriction set on the implementation by the Erlang specification is that
order is total, i.e. satisfies <em>antisymmetry</em>, <em>transitivity</em> and <em>totality</em>.</p>

<ul>
  <li>If <code>M1 =&lt; M2</code> and <code>M2 =&lt; M1</code> then <code>M1 == M2</code>,</li>
  <li>If <code>M1 =&lt; M2</code> and <code>M2 =&lt; M3</code> then <code>M1 =&lt; M3</code>,</li>
  <li>If <code>M1 =&lt; M2</code> or <code>M2 =&lt; M1</code> (always comparable)
where <code>M1</code>, <code>M2</code> and <code>M3</code> are any Map term.</li>
</ul>

<p>This only holds true in Erlang if we treat floats and integers as union of types,
namely numbers. In the case of a Maps, <code>true = #{ 1.0 =&gt; V } == #{ 1 =&gt; V}</code>.</p>

<ul>
  <li>The need for order arises in a few cases.
    <ul>
      <li>comparison, for example sorting, <code>lists:sort([M1, .., Mn])</code></li>
      <li>introspection, for example when printed.</li>
    </ul>
  </li>
  <li>Ordered maps impose restrictions on the underlying implementation and a
hashing approach will be nearly impossible.</li>
  <li>The underlying structure does not need to be sorted, an order could be
produced when needed,
    <ul>
      <li><code>M1</code> &lt; <code>M2</code>, would result in an internal sort but would cost
O( <em>N1</em> * lg <em>N1</em> + <em>N2</em> * lg <em>N2</em> ), where
<code>N1 = maps:size(M1) and N2 = maps:size(M2)</code></li>
    </ul>
  </li>
</ul>
      <h2 id="accessing-a-single-value-1">
        
        
          Accessing a single value <a href="#accessing-a-single-value-1">#</a>
        
        
      </h2>
    

<p>Do we need to have single access or is matching sufficient?</p>

<p>Consider the following,</p>

<pre><code class="language-erlang">V = M#{ K }
</code></pre>

<p>is shorter than</p>

<pre><code class="language-erlang">#{ K := V } = M
</code></pre>

<p>It also allows for easy access of associated values in deep structures.</p>

<p>The syntax for single value access is the least developed (and contemplated)
feature in this proposal and certainly could use some input.</p>

<p>More over, the dot syntax must be abolished. Currently it is used for records
but it will not be used for maps. Dot represents end of expression list in last
clause, or end of attribute.</p>

<p>It cannot be used to distinguish between floats or associations.</p>

<p>Example:</p>

<pre><code class="language-erlang">1&gt; M = #{ 1.1 =&gt; a, 1 =&gt; #{ 1 =&gt; b } }.
#{ 1 =&gt; #{ 1 =&gt; b }, 1.1 =&gt; a }.

2&gt; #M.1.1.
a | b ?
</code></pre>
      <h1 id="backwards-compatibility">
        
        
          Backwards Compatibility <a href="#backwards-compatibility">#</a>
        
        
      </h1>
    

<p>Erlang code written with Maps will only be parseable, loadable and executable 
on Erlang/OTP R17A and later releases of Erlang/OTP but not on previous
releases.</p>

<p>Erlang code written before Erlang/OTP R17A will be perfectly compatible, i.e.
parseable, loadable and executable with these Maps changes.</p>

<p>Distribution will not be backwards compatible.</p>
      <h1 id="copyright">
        
        
          Copyright <a href="#copyright">#</a>
        
        
      </h1>
    

<p>This document has been placed in the public domain.</p>

            </div>
        </div>
    </div>
</div>
<script src="/assets/js/prismjs/prism.js"></script>
<script src="/assets/js/prismjs/components/prism-erlang.js"></script>
    <footer class="container-fluid footer text-center border-top border-bottom">
        <div>
            <a href="/downloads.html" title="DOWNLOAD"><img src="/assets/img/download.png" alt="Download Erlang/OTP"></a>
        </div>
        <div>
            <a href="http://www.github.com/erlang/otp"><img
                    src="/assets/img/GitHub-Mark-32px.png" alt="Erlang/OTP on Github"></a>
        </div>
        
        <div>
            <a href="http://www.twitter.com/erlang_org"><img src="/assets/img/twitter.png"
                    width="32" alt="Erlang/OTP twitter"></a>
        </div>
    </footer>
    <script src="/assets/js/bootstrap/dist/js/bootstrap.bundle.min.js"></script>
</body>

</html>